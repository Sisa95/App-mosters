!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).turf = {}) }(this, (function (t) {
    "use strict"; var e = 6371008.8, n = { centimeters: 637100880, centimetres: 637100880, degrees: 57.22891354143274, feet: 20902260.511392, inches: 39.37 * e, kilometers: 6371.0088, kilometres: 6371.0088, meters: e, metres: e, miles: 3958.761333810546, millimeters: 6371008800, millimetres: 6371008800, nauticalmiles: e / 1852, radians: 1, yards: 5825721.287490856 }, r = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / e, yards: 1 / 1.0936 }, i = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }; function o(t, e, n) { void 0 === n && (n = {}); var r = { type: "Feature" }; return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r } function s(t, e, n) { switch (t) { case "Point": return a(e).geometry; case "LineString": return h(e).geometry; case "Polygon": return l(e).geometry; case "MultiPoint": return d(e).geometry; case "MultiLineString": return g(e).geometry; case "MultiPolygon": return y(e).geometry; default: throw new Error(t + " is invalid") } } function a(t, e, n) { if (void 0 === n && (n = {}), !t) throw new Error("coordinates is required"); if (!Array.isArray(t)) throw new Error("coordinates must be an Array"); if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!C(t[0]) || !C(t[1])) throw new Error("coordinates must contain numbers"); return o({ type: "Point", coordinates: t }, e, n) } function u(t, e, n) { return void 0 === n && (n = {}), f(t.map((function (t) { return a(t, e) })), n) } function l(t, e, n) { void 0 === n && (n = {}); for (var r = 0, i = t; r < i.length; r++) { var s = i[r]; if (s.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < s[s.length - 1].length; a++)if (s[s.length - 1][a] !== s[0][a]) throw new Error("First and last Position are not equivalent.") } return o({ type: "Polygon", coordinates: t }, e, n) } function c(t, e, n) { return void 0 === n && (n = {}), f(t.map((function (t) { return l(t, e) })), n) } function h(t, e, n) { if (void 0 === n && (n = {}), t.length < 2) throw new Error("coordinates must be an array of two or more positions"); return o({ type: "LineString", coordinates: t }, e, n) } function p(t, e, n) { return void 0 === n && (n = {}), f(t.map((function (t) { return h(t, e) })), n) } function f(t, e) { void 0 === e && (e = {}); var n = { type: "FeatureCollection" }; return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n } function g(t, e, n) { return void 0 === n && (n = {}), o({ type: "MultiLineString", coordinates: t }, e, n) } function d(t, e, n) { return void 0 === n && (n = {}), o({ type: "MultiPoint", coordinates: t }, e, n) } function y(t, e, n) { return void 0 === n && (n = {}), o({ type: "MultiPolygon", coordinates: t }, e, n) } function v(t, e, n) { return void 0 === n && (n = {}), o({ type: "GeometryCollection", geometries: t }, e, n) } function _(t, e) { if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error("precision must be a positive number"); var n = Math.pow(10, e || 0); return Math.round(t * n) / n } function m(t, e) { void 0 === e && (e = "kilometers"); var r = n[e]; if (!r) throw new Error(e + " units is invalid"); return t * r } function x(t, e) { void 0 === e && (e = "kilometers"); var r = n[e]; if (!r) throw new Error(e + " units is invalid"); return t / r } function E(t, e) { return w(x(t, e)) } function b(t) { var e = t % 360; return e < 0 && (e += 360), e } function w(t) { return 180 * (t % (2 * Math.PI)) / Math.PI } function I(t) { return t % 360 * Math.PI / 180 } function N(t, e, n) { if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("length must be a positive number"); return m(x(t, e), n) } function S(t, e, n) { if (void 0 === e && (e = "meters"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("area must be a positive number"); var r = i[e]; if (!r) throw new Error("invalid original units"); var o = i[n]; if (!o) throw new Error("invalid final units"); return t / r * o } function C(t) { return !isNaN(t) && null !== t && !Array.isArray(t) } function P(t) { return !!t && t.constructor === Object } function L(t) { if (!t) throw new Error("bbox is required"); if (!Array.isArray(t)) throw new Error("bbox must be an Array"); if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); t.forEach((function (t) { if (!C(t)) throw new Error("bbox must only contain numbers") })) } function M(t) { if (!t) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof t)) throw new Error("id must be a number or a string") } var O = Object.freeze({ __proto__: null, earthRadius: e, factors: n, unitsFactors: r, areaFactors: i, feature: o, geometry: s, point: a, points: u, polygon: l, polygons: c, lineString: h, lineStrings: p, featureCollection: f, multiLineString: g, multiPoint: d, multiPolygon: y, geometryCollection: v, round: _, radiansToLength: m, lengthToRadians: x, lengthToDegrees: E, bearingToAzimuth: b, radiansToDegrees: w, degreesToRadians: I, convertLength: N, convertArea: S, isNumber: C, isObject: P, validateBBox: L, validateId: M }); function R(t) { if (!t) throw new Error("coord is required"); if (!Array.isArray(t)) { if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type) return t.geometry.coordinates; if ("Point" === t.type) return t.coordinates } if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return t; throw new Error("coord must be GeoJSON Point or an Array of numbers") } function T(t) { if (Array.isArray(t)) return t; if ("Feature" === t.type) { if (null !== t.geometry) return t.geometry.coordinates } else if (t.coordinates) return t.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") } function A(t) { if (t.length > 1 && C(t[0]) && C(t[1])) return !0; if (Array.isArray(t[0]) && t[0].length) return A(t[0]); throw new Error("coordinates must only contain numbers") } function D(t, e, n) { if (!e || !n) throw new Error("type and name required"); if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type) } function F(t, e, n) { if (!t) throw new Error("No feature passed"); if (!n) throw new Error(".featureOf() requires a name"); if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required"); if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type) } function k(t, e, n) { if (!t) throw new Error("No featureCollection passed"); if (!n) throw new Error(".collectionOf() requires a name"); if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required"); for (var r = 0, i = t.features; r < i.length; r++) { var o = i[r]; if (!o || "Feature" !== o.type || !o.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required"); if (!o.geometry || o.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + o.geometry.type) } } function G(t) { return "Feature" === t.type ? t.geometry : t } function q(t, e) { return "FeatureCollection" === t.type ? "FeatureCollection" : "GeometryCollection" === t.type ? "GeometryCollection" : "Feature" === t.type && null !== t.geometry ? t.geometry.type : t.type } var B = Object.freeze({ __proto__: null, getCoord: R, getCoords: T, containsNumber: A, geojsonType: D, featureOf: F, collectionOf: k, getGeom: G, getType: q }); function z(t, e, n) { if (null !== t) for (var r, i, o, s, a, u, l, c, h = 0, p = 0, f = t.type, g = "FeatureCollection" === f, d = "Feature" === f, y = g ? t.features.length : 1, v = 0; v < y; v++) { a = (c = !!(l = g ? t.features[v].geometry : d ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var _ = 0; _ < a; _++) { var m = 0, x = 0; if (null !== (s = c ? l.geometries[_] : l)) { u = s.coordinates; var E = s.type; switch (h = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) { case null: break; case "Point": if (!1 === e(u, p, v, m, x)) return !1; p++, m++; break; case "LineString": case "MultiPoint": for (r = 0; r < u.length; r++) { if (!1 === e(u[r], p, v, m, x)) return !1; p++, "MultiPoint" === E && m++ } "LineString" === E && m++; break; case "Polygon": case "MultiLineString": for (r = 0; r < u.length; r++) { for (i = 0; i < u[r].length - h; i++) { if (!1 === e(u[r][i], p, v, m, x)) return !1; p++ } "MultiLineString" === E && m++, "Polygon" === E && x++ } "Polygon" === E && m++; break; case "MultiPolygon": for (r = 0; r < u.length; r++) { for (x = 0, i = 0; i < u[r].length; i++) { for (o = 0; o < u[r][i].length - h; o++) { if (!1 === e(u[r][i][o], p, v, m, x)) return !1; p++ } x++ } m++ } break; case "GeometryCollection": for (r = 0; r < s.geometries.length; r++)if (!1 === z(s.geometries[r], e, n)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function j(t, e, n, r) { var i = n; return z(t, (function (t, r, o, s, a) { i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a) }), r), i } function U(t, e) { var n; switch (t.type) { case "FeatureCollection": for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++); break; case "Feature": e(t.properties, 0) } } function V(t, e, n) { var r = n; return U(t, (function (t, i) { r = 0 === i && void 0 === n ? t : e(r, t, i) })), r } function X(t, e) { if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++); } function Y(t, e, n) { var r = n; return X(t, (function (t, i) { r = 0 === i && void 0 === n ? t : e(r, t, i) })), r } function H(t) { var e = []; return z(t, (function (t) { e.push(t) })), e } function W(t, e) { var n, r, i, o, s, a, u, l, c, h, p = 0, f = "FeatureCollection" === t.type, g = "Feature" === t.type, d = f ? t.features.length : 1; for (n = 0; n < d; n++) { for (a = f ? t.features[n].geometry : g ? t.geometry : t, l = f ? t.features[n].properties : g ? t.properties : {}, c = f ? t.features[n].bbox : g ? t.bbox : void 0, h = f ? t.features[n].id : g ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++)if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === e(o, p, l, c, h)) return !1; break; case "GeometryCollection": for (r = 0; r < o.geometries.length; r++)if (!1 === e(o.geometries[r], p, l, c, h)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === e(null, p, l, c, h)) return !1; p++ } } function J(t, e, n) { var r = n; return W(t, (function (t, i, o, s, a) { r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a) })), r } function Z(t, e) { W(t, (function (t, n, r, i, s) { var a, u = null === t ? null : t.type; switch (u) { case null: case "Point": case "LineString": case "Polygon": return !1 !== e(o(t, r, { bbox: i, id: s }), n, 0) && void 0 }switch (u) { case "MultiPoint": a = "Point"; break; case "MultiLineString": a = "LineString"; break; case "MultiPolygon": a = "Polygon" }for (var l = 0; l < t.coordinates.length; l++) { var c = t.coordinates[l]; if (!1 === e(o({ type: a, coordinates: c }, r), n, l)) return !1 } })) } function K(t, e, n) { var r = n; return Z(t, (function (t, i, o) { r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o) })), r } function Q(t, e) { Z(t, (function (t, n, r) { var i = 0; if (t.geometry) { var o = t.geometry.type; if ("Point" !== o && "MultiPoint" !== o) { var s, a = 0, u = 0, l = 0; return !1 !== z(t, (function (o, c, p, f, g) { if (void 0 === s || n > a || f > u || g > l) return s = o, a = n, u = f, l = g, void (i = 0); var d = h([s, o], t.properties); if (!1 === e(d, n, r, g, i)) return !1; i++, s = o })) && void 0 } } })) } function $(t, e, n) { var r = n, i = !1; return Q(t, (function (t, o, s, a, u) { r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0 })), r } function tt(t, e) { if (!t) throw new Error("geojson is required"); Z(t, (function (t, n, r) { if (null !== t.geometry) { var i = t.geometry.type, o = t.geometry.coordinates; switch (i) { case "LineString": if (!1 === e(t, n, r, 0, 0)) return !1; break; case "Polygon": for (var s = 0; s < o.length; s++)if (!1 === e(h(o[s], t.properties), n, r, s)) return !1 } } })) } function et(t, e, n) { var r = n; return tt(t, (function (t, i, o, s) { r = 0 === i && void 0 === n ? t : e(r, t, i, o, s) })), r } function nt(t, e) { if (!P(e = e || {})) throw new Error("options is invalid"); var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.segmentIndex || 0, a = e.properties; switch (t.type) { case "FeatureCollection": r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry; break; case "Feature": a = a || t.properties, n = t.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": n = t; break; default: throw new Error("geojson is invalid") }if (null === n) return null; var u = n.coordinates; switch (n.type) { case "Point": case "MultiPoint": return null; case "LineString": return s < 0 && (s = u.length + s - 1), h([u[s], u[s + 1]], a, e); case "Polygon": return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), h([u[o][s], u[o][s + 1]], a, e); case "MultiLineString": return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), h([u[i][s], u[i][s + 1]], a, e); case "MultiPolygon": return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), h([u[i][o][s], u[i][o][s + 1]], a, e) }throw new Error("geojson is invalid") } function rt(t, e) { if (!P(e = e || {})) throw new Error("options is invalid"); var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.coordIndex || 0, u = e.properties; switch (t.type) { case "FeatureCollection": r < 0 && (r = t.features.length + r), u = u || t.features[r].properties, n = t.features[r].geometry; break; case "Feature": u = u || t.properties, n = t.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": n = t; break; default: throw new Error("geojson is invalid") }if (null === n) return null; var l = n.coordinates; switch (n.type) { case "Point": return a(l, u, e); case "MultiPoint": return i < 0 && (i = l.length + i), a(l[i], u, e); case "LineString": return s < 0 && (s = l.length + s), a(l[s], u, e); case "Polygon": return o < 0 && (o = l.length + o), s < 0 && (s = l[o].length + s), a(l[o][s], u, e); case "MultiLineString": return i < 0 && (i = l.length + i), s < 0 && (s = l[i].length + s), a(l[i][s], u, e); case "MultiPolygon": return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), s < 0 && (s = l[i][o].length - s), a(l[i][o][s], u, e) }throw new Error("geojson is invalid") } var it = Object.freeze({ __proto__: null, coordEach: z, coordReduce: j, propEach: U, propReduce: V, featureEach: X, featureReduce: Y, coordAll: H, geomEach: W, geomReduce: J, flattenEach: Z, flattenReduce: K, segmentEach: Q, segmentReduce: $, lineEach: tt, lineReduce: et, findSegment: nt, findPoint: rt }); function ot(t) { var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return z(t, (function (t) { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]) })), e } ot.default = ot;
    /*
        object-assign
        (c) Sindre Sorhus
        @license MIT
        */
    var st = Object.getOwnPropertySymbols, at = Object.prototype.hasOwnProperty, ut = Object.prototype.propertyIsEnumerable; function lt(t) { if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } var ct = function () { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, n = 0; n < 10; n++)e["_" + String.fromCharCode(n)] = n; if ("0123456789" !== Object.getOwnPropertyNames(e).map((function (t) { return e[t] })).join("")) return !1; var r = {}; return "abcdefghijklmnopqrst".split("").forEach((function (t) { r[t] = t })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("") } catch (t) { return !1 } }() ? Object.assign : function (t, e) { for (var n, r, i = lt(t), o = 1; o < arguments.length; o++) { for (var s in n = Object(arguments[o])) at.call(n, s) && (i[s] = n[s]); if (st) { r = st(n); for (var a = 0; a < r.length; a++)ut.call(n, r[a]) && (i[r[a]] = n[r[a]]) } } return i }, ht = { successCallback: null, verbose: !1 }, pt = {};
/**
     * @license GNU Affero General Public License.
     * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
     * v. 1.2.0
     * https://github.com/RaumZeit/MarchingSquares.js
     *
     * MarchingSquaresJS is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Affero General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * MarchingSquaresJS is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU Affero General Public License for more details.
     *
     * As additional permission under GNU Affero General Public License version 3
     * section 7, third-party projects (personal or commercial) may distribute,
     * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
     * requirement that said third-party project for that reason alone becomes
     * subject to any requirement of the GNU Affero General Public License version 3.
     * Any modifications to MarchingSquaresJS, however, must be shared with the public
     * and made available.
     *
     * In summary this:
     * - allows you to use MarchingSquaresJS at no cost
     * - allows you to use MarchingSquaresJS for both personal and commercial purposes
     * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
     *   license as long as this license notice is included
     * - enables you to keep the source code of your program that uses MarchingSquaresJS
     *   undisclosed
     * - forces you to share any modifications you have made to MarchingSquaresJS,
     *   e.g. bug-fixes
     *
     * You should have received a copy of the GNU Affero General Public License
     * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
     */function ft(t, e, n) { n = n || {}; for (var r = Object.keys(ht), i = 0; i < r.length; i++) { var o = r[i], s = n[o]; s = null != s ? s : ht[o], pt[o] = s } pt.verbose && console.log("MarchingSquaresJS-isoContours: computing isocontour for " + e); var a = function (t) { var e = [], n = 0, r = 1e-7; return t.cells.forEach((function (i, o) { i.forEach((function (i, s) { if (void 0 !== i && (5 !== (f = i).cval && 10 !== f.cval) && !dt(i)) { var a = function (t, e, n) { var r, i, o = t.length, s = [], a = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0], u = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0], l = ["none", "left", "bottom", "left", "right", "none", "bottom", "left", "top", "top", "none", "top", "right", "right", "bottom", "none"], c = ["none", "bottom", "right", "right", "top", "top", "top", "top", "left", "bottom", "right", "right", "left", "bottom", "left", "none"], h = t[e][n], p = h.cval, f = l[p], g = vt(h, f); s.push([n + g[0], e + g[1]]), f = c[p], g = vt(h, f), s.push([n + g[0], e + g[1]]), yt(h); var d = n + a[p], y = e + u[p], v = p; for (; d >= 0 && y >= 0 && y < o && (d != n || y != e) && void 0 !== (h = t[y][d]);) { if (0 === (p = h.cval) || 15 === p) return { path: s, info: "mergeable" }; f = c[p], r = a[p], i = u[p], 5 !== p && 10 !== p || (5 === p ? h.flipped ? -1 === u[v] ? (f = "left", r = -1, i = 0) : (f = "right", r = 1, i = 0) : -1 === a[v] && (f = "bottom", r = 0, i = -1) : 10 === p && (h.flipped ? -1 === a[v] ? (f = "top", r = 0, i = 1) : (f = "bottom", r = 0, i = -1) : 1 === u[v] && (f = "left", r = -1, i = 0))), g = vt(h, f), s.push([d + g[0], y + g[1]]), yt(h), d += r, y += i, v = p } return { path: s, info: "closed" } }(t.cells, o, s), u = !1; if ("mergeable" === a.info) for (var l = a.path[a.path.length - 1][0], c = a.path[a.path.length - 1][1], h = n - 1; h >= 0; h--)if (Math.abs(e[h][0][0] - l) <= r && Math.abs(e[h][0][1] - c) <= r) { for (var p = a.path.length - 2; p >= 0; --p)e[h].unshift(a.path[p]); u = !0; break } u || (e[n++] = a.path) } var f })) })), e }(function (t, e) { for (var n = t.length - 1, r = t[0].length - 1, i = { rows: n, cols: r, cells: [] }, o = 0; o < n; ++o) { i.cells[o] = []; for (var s = 0; s < r; ++s) { var a = 0, u = t[o + 1][s], l = t[o + 1][s + 1], c = t[o][s + 1], h = t[o][s]; if (!(isNaN(u) || isNaN(l) || isNaN(c) || isNaN(h))) { a |= u >= e ? 8 : 0, a |= l >= e ? 4 : 0, a |= c >= e ? 2 : 0; var p, f, g, d, y = !1; if (5 === (a |= h >= e ? 1 : 0) || 10 === a) { var v = (u + l + c + h) / 4; 5 === a && v < e ? (a = 10, y = !0) : 10 === a && v < e && (a = 5, y = !0) } if (0 !== a && 15 !== a) p = f = g = d = .5, 1 === a ? (g = 1 - gt(e, u, h), f = 1 - gt(e, c, h)) : 2 === a ? (f = gt(e, h, c), d = 1 - gt(e, l, c)) : 3 === a ? (g = 1 - gt(e, u, h), d = 1 - gt(e, l, c)) : 4 === a ? (p = gt(e, u, l), d = gt(e, c, l)) : 5 === a ? (p = gt(e, u, l), d = gt(e, c, l), f = 1 - gt(e, c, h), g = 1 - gt(e, u, h)) : 6 === a ? (f = gt(e, h, c), p = gt(e, u, l)) : 7 === a ? (g = 1 - gt(e, u, h), p = gt(e, u, l)) : 8 === a ? (g = gt(e, h, u), p = 1 - gt(e, l, u)) : 9 === a ? (f = 1 - gt(e, c, h), p = 1 - gt(e, l, u)) : 10 === a ? (p = 1 - gt(e, l, u), d = 1 - gt(e, l, c), f = gt(e, h, c), g = gt(e, h, u)) : 11 === a ? (p = 1 - gt(e, l, u), d = 1 - gt(e, l, c)) : 12 === a ? (g = gt(e, h, u), d = gt(e, c, l)) : 13 === a ? (f = 1 - gt(e, c, h), d = gt(e, c, l)) : 14 === a ? (g = gt(e, h, u), f = gt(e, h, c)) : console.log("MarchingSquaresJS-isoContours: Illegal cval detected: " + a), i.cells[o][s] = { cval: a, flipped: y, top: p, right: d, bottom: f, left: g } } } } return i }(t, e)); return "function" == typeof pt.successCallback && pt.successCallback(a), a } function gt(t, e, n) { return (t - e) / (n - e) } function dt(t) { return 0 === t.cval || 15 === t.cval } function yt(t) { dt(t) || 5 === t.cval || 10 === t.cval || (t.cval = 15) } function vt(t, e) { return "top" === e ? [t.top, 1] : "bottom" === e ? [t.bottom, 0] : "right" === e ? [1, t.right] : "left" === e ? [0, t.left] : void 0 } function _t(t, e) { if (!P(e = e || {})) throw new Error("options is invalid"); var n = e.zProperty || "elevation", r = e.flip, i = e.flags; k(t, "Point", "input must contain Points"); for (var o = function (t, e) { var n = {}; return X(t, (function (t) { var e = T(t)[1]; n[e] || (n[e] = []), n[e].push(t) })), Object.keys(n).map((function (t) { return n[t].sort((function (t, e) { return T(t)[0] - T(e)[0] })) })).sort((function (t, n) { return e ? T(t[0])[1] - T(n[0])[1] : T(n[0])[1] - T(t[0])[1] })) }(t, r), s = [], a = 0; a < o.length; a++) { for (var u = o[a], l = [], c = 0; c < u.length; c++) { var h = u[c]; h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [a, c]) } s.push(l) } return s } var mt = Et, xt = Et; function Et(t, e, n, r, i) { bt(t, e, n || 0, r || t.length - 1, i || It) } function bt(t, e, n, r, i) { for (; r > n;) { if (r - n > 600) { var o = r - n + 1, s = e - n + 1, a = Math.log(o), u = .5 * Math.exp(2 * a / 3), l = .5 * Math.sqrt(a * u * (o - u) / o) * (s - o / 2 < 0 ? -1 : 1); bt(t, e, Math.max(n, Math.floor(e - s * u / o + l)), Math.min(r, Math.floor(e + (o - s) * u / o + l)), i) } var c = t[e], h = n, p = r; for (wt(t, n, e), i(t[r], c) > 0 && wt(t, n, r); h < p;) { for (wt(t, h, p), h++, p--; i(t[h], c) < 0;)h++; for (; i(t[p], c) > 0;)p-- } 0 === i(t[n], c) ? wt(t, n, p) : wt(t, ++p, r), p <= e && (n = p + 1), e <= p && (r = p - 1) } } function wt(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function It(t, e) { return t < e ? -1 : t > e ? 1 : 0 } mt.default = xt; var Nt = Ct, St = Ct; function Ct(t, e) { if (!(this instanceof Ct)) return new Ct(t, e); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear() } function Pt(t, e, n) { if (!n) return e.indexOf(t); for (var r = 0; r < e.length; r++)if (n(t, e[r])) return r; return -1 } function Lt(t, e) { Mt(t, 0, t.children.length, e, t) } function Mt(t, e, n, r, i) { i || (i = Gt(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0; for (var o, s = e; s < n; s++)o = t.children[s], Ot(i, t.leaf ? r(o) : o); return i } function Ot(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function Rt(t, e) { return t.minX - e.minX } function Tt(t, e) { return t.minY - e.minY } function At(t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function Dt(t) { return t.maxX - t.minX + (t.maxY - t.minY) } function Ft(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function kt(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function Gt(t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function qt(t, e, n, r, i) { for (var o, s = [e, n]; s.length;)(n = s.pop()) - (e = s.pop()) <= r || (o = e + Math.ceil((n - e) / r / 2) * r, mt(t, o, e, n, i), s.push(e, o, o, n)) } function Bt(t) { var e = { exports: {} }; return t(e, e.exports), e.exports } Ct.prototype = { all: function () { return this._all(this.data, []) }, search: function (t) { var e = this.data, n = [], r = this.toBBox; if (!kt(t, e)) return n; for (var i, o, s, a, u = []; e;) { for (i = 0, o = e.children.length; i < o; i++)s = e.children[i], kt(t, a = e.leaf ? r(s) : s) && (e.leaf ? n.push(s) : Ft(t, a) ? this._all(s, n) : u.push(s)); e = u.pop() } return n }, collides: function (t) { var e = this.data, n = this.toBBox; if (!kt(t, e)) return !1; for (var r, i, o, s, a = []; e;) { for (r = 0, i = e.children.length; r < i; r++)if (o = e.children[r], kt(t, s = e.leaf ? n(o) : o)) { if (e.leaf || Ft(t, s)) return !0; a.push(o) } e = a.pop() } return !1 }, load: function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (var e = 0, n = t.length; e < n; e++)this.insert(t[e]); return this } var r = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === r.height) this._splitRoot(this.data, r); else { if (this.data.height < r.height) { var i = this.data; this.data = r, r = i } this._insert(r, this.data.height - r.height - 1, !0) } else this.data = r; return this }, insert: function (t) { return t && this._insert(t, this.data.height - 1), this }, clear: function () { return this.data = Gt([]), this }, remove: function (t, e) { if (!t) return this; for (var n, r, i, o, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) { if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), o = !0), s.leaf && -1 !== (i = Pt(t, s.children, e))) return s.children.splice(i, 1), u.push(s), this._condense(u), this; o || s.leaf || !Ft(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0]) } return this }, toBBox: function (t) { return t }, compareMinX: Rt, compareMinY: Tt, toJSON: function () { return this.data }, fromJSON: function (t) { return this.data = t, this }, _all: function (t, e) { for (var n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, _build: function (t, e, n, r) { var i, o = n - e + 1, s = this._maxEntries; if (o <= s) return Lt(i = Gt(t.slice(e, n + 1)), this.toBBox), i; r || (r = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, r - 1))), (i = Gt([])).leaf = !1, i.height = r; var a, u, l, c, h = Math.ceil(o / s), p = h * Math.ceil(Math.sqrt(s)); for (qt(t, e, n, p, this.compareMinX), a = e; a <= n; a += p)for (qt(t, a, l = Math.min(a + p - 1, n), h, this.compareMinY), u = a; u <= l; u += h)c = Math.min(u + h - 1, l), i.children.push(this._build(t, u, c, r - 1)); return Lt(i, this.toBBox), i }, _chooseSubtree: function (t, e, n, r) { for (var i, o, s, a, u, l, c, h, p, f; r.push(e), !e.leaf && r.length - 1 !== n;) { for (c = h = 1 / 0, i = 0, o = e.children.length; i < o; i++)u = At(s = e.children[i]), p = t, f = s, (l = (Math.max(f.maxX, p.maxX) - Math.min(f.minX, p.minX)) * (Math.max(f.maxY, p.maxY) - Math.min(f.minY, p.minY)) - u) < h ? (h = l, c = u < c ? u : c, a = s) : l === h && u < c && (c = u, a = s); e = a || e.children[0] } return e }, _insert: function (t, e, n) { var r = this.toBBox, i = n ? t : r(t), o = [], s = this._chooseSubtree(i, this.data, e, o); for (s.children.push(t), Ot(s, i); e >= 0 && o[e].children.length > this._maxEntries;)this._split(o, e), e--; this._adjustParentBBoxes(i, o, e) }, _split: function (t, e) { var n = t[e], r = n.children.length, i = this._minEntries; this._chooseSplitAxis(n, i, r); var o = this._chooseSplitIndex(n, i, r), s = Gt(n.children.splice(o, n.children.length - o)); s.height = n.height, s.leaf = n.leaf, Lt(n, this.toBBox), Lt(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(n, s) }, _splitRoot: function (t, e) { this.data = Gt([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Lt(this.data, this.toBBox) }, _chooseSplitIndex: function (t, e, n) { var r, i, o, s, a, u, l, c, h, p, f, g, d, y; for (u = l = 1 / 0, r = e; r <= n - e; r++)i = Mt(t, 0, r, this.toBBox), o = Mt(t, r, n, this.toBBox), h = i, p = o, f = void 0, g = void 0, d = void 0, y = void 0, f = Math.max(h.minX, p.minX), g = Math.max(h.minY, p.minY), d = Math.min(h.maxX, p.maxX), y = Math.min(h.maxY, p.maxY), s = Math.max(0, d - f) * Math.max(0, y - g), a = At(i) + At(o), s < u ? (u = s, c = r, l = a < l ? a : l) : s === u && a < l && (l = a, c = r); return c }, _chooseSplitAxis: function (t, e, n) { var r = t.leaf ? this.compareMinX : Rt, i = t.leaf ? this.compareMinY : Tt; this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r) }, _allDistMargin: function (t, e, n, r) { t.children.sort(r); var i, o, s = this.toBBox, a = Mt(t, 0, e, s), u = Mt(t, n - e, n, s), l = Dt(a) + Dt(u); for (i = e; i < n - e; i++)o = t.children[i], Ot(a, t.leaf ? s(o) : o), l += Dt(a); for (i = n - e - 1; i >= e; i--)o = t.children[i], Ot(u, t.leaf ? s(o) : o), l += Dt(u); return l }, _adjustParentBBoxes: function (t, e, n) { for (var r = n; r >= 0; r--)Ot(e[r], t) }, _condense: function (t) { for (var e, n = t.length - 1; n >= 0; n--)0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : Lt(t[n], this.toBBox) }, _initFormat: function (t) { var e = ["return a", " - b", ";"]; this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};") } }, Nt.default = St; var zt = function (t, e, n) { var r = t * e, i = jt * t, o = i - (i - t), s = t - o, a = jt * e, u = a - (a - e), l = e - u, c = s * l - (r - o * u - s * u - o * l); if (n) return n[0] = c, n[1] = r, n; return [c, r] }, jt = +(Math.pow(2, 27) + 1); var Ut = function (t, e) { var n = 0 | t.length, r = 0 | e.length; if (1 === n && 1 === r) return function (t, e) { var n = t + e, r = n - t, i = t - (n - r) + (e - r); if (i) return [i, n]; return [n] }(t[0], e[0]); var i, o, s = new Array(n + r), a = 0, u = 0, l = 0, c = Math.abs, h = t[u], p = c(h), f = e[l], g = c(f); p < g ? (o = h, (u += 1) < n && (h = t[u], p = c(h))) : (o = f, (l += 1) < r && (f = e[l], g = c(f))); u < n && p < g || l >= r ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = e[l], g = c(f))); var d, y, v = i + o, _ = v - i, m = o - _, x = m, E = v; for (; u < n && l < r;)p < g ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = e[l], g = c(f))), (m = (o = x) - (_ = (v = i + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d; for (; u < n;)(m = (o = x) - (_ = (v = (i = h) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (u += 1) < n && (h = t[u]); for (; l < r;)(m = (o = x) - (_ = (v = (i = f) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (l += 1) < r && (f = e[l]); x && (s[a++] = x); E && (s[a++] = E); a || (s[a++] = 0); return s.length = a, s }; var Vt = function (t, e, n) { var r = t + e, i = r - t, o = e - i, s = t - (r - i); if (n) return n[0] = s + o, n[1] = r, n; return [s + o, r] }; var Xt = function (t, e) { var n = t.length; if (1 === n) { var r = zt(t[0], e); return r[0] ? r : [r[1]] } var i = new Array(2 * n), o = [.1, .1], s = [.1, .1], a = 0; zt(t[0], e, o), o[0] && (i[a++] = o[0]); for (var u = 1; u < n; ++u) { zt(t[u], e, s); var l = o[1]; Vt(l, s[0], o), o[0] && (i[a++] = o[0]); var c = s[1], h = o[1], p = c + h, f = h - (p - c); o[1] = p, f && (i[a++] = f) } o[1] && (i[a++] = o[1]); 0 === a && (i[a++] = 0); return i.length = a, i }; var Yt = function (t, e) { var n = 0 | t.length, r = 0 | e.length; if (1 === n && 1 === r) return function (t, e) { var n = t + e, r = n - t, i = t - (n - r) + (e - r); if (i) return [i, n]; return [n] }(t[0], -e[0]); var i, o, s = new Array(n + r), a = 0, u = 0, l = 0, c = Math.abs, h = t[u], p = c(h), f = -e[l], g = c(f); p < g ? (o = h, (u += 1) < n && (h = t[u], p = c(h))) : (o = f, (l += 1) < r && (f = -e[l], g = c(f))); u < n && p < g || l >= r ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = -e[l], g = c(f))); var d, y, v = i + o, _ = v - i, m = o - _, x = m, E = v; for (; u < n && l < r;)p < g ? (i = h, (u += 1) < n && (h = t[u], p = c(h))) : (i = f, (l += 1) < r && (f = -e[l], g = c(f))), (m = (o = x) - (_ = (v = i + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d; for (; u < n;)(m = (o = x) - (_ = (v = (i = h) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (u += 1) < n && (h = t[u]); for (; l < r;)(m = (o = x) - (_ = (v = (i = f) + o) - i)) && (s[a++] = m), x = E - ((d = E + v) - (y = d - E)) + (v - y), E = d, (l += 1) < r && (f = -e[l]); x && (s[a++] = x); E && (s[a++] = E); a || (s[a++] = 0); return s.length = a, s }; var Ht = Bt((function (t) { function e(t, e) { for (var n = new Array(t.length - 1), r = 1; r < t.length; ++r)for (var i = n[r - 1] = new Array(t.length - 1), o = 0, s = 0; o < t.length; ++o)o !== e && (i[s++] = t[r][o]); return n } function n(t) { if (1 === t.length) return t[0]; if (2 === t.length) return ["sum(", t[0], ",", t[1], ")"].join(""); var e = t.length >> 1; return ["sum(", n(t.slice(0, e)), ",", n(t.slice(e)), ")"].join("") } function r(t) { if (2 === t.length) return [["sum(prod(", t[0][0], ",", t[1][1], "),prod(-", t[0][1], ",", t[1][0], "))"].join("")]; for (var i = [], o = 0; o < t.length; ++o)i.push(["scale(", n(r(e(t, o))), ",", (s = o, 1 & s ? "-" : ""), t[0][o], ")"].join("")); return i; var s } function i(t) { for (var i = [], o = [], s = function (t) { for (var e = new Array(t), n = 0; n < t; ++n) { e[n] = new Array(t); for (var r = 0; r < t; ++r)e[n][r] = ["m", r, "[", t - n - 1, "]"].join("") } return e }(t), a = [], u = 0; u < t; ++u)0 == (1 & u) ? i.push.apply(i, r(e(s, u))) : o.push.apply(o, r(e(s, u))), a.push("m" + u); var l = n(i), c = n(o), h = "orientation" + t + "Exact", p = ["function ", h, "(", a.join(), "){var p=", l, ",n=", c, ",d=sub(p,n);return d[d.length-1];};return ", h].join(""); return new Function("sum", "prod", "scale", "sub", p)(Ut, zt, Xt, Yt) } var o = i(3), s = i(4), a = [function () { return 0 }, function () { return 0 }, function (t, e) { return e[0] - t[0] }, function (t, e, n) { var r, i = (t[1] - n[1]) * (e[0] - n[0]), s = (t[0] - n[0]) * (e[1] - n[1]), a = i - s; if (i > 0) { if (s <= 0) return a; r = i + s } else { if (!(i < 0)) return a; if (s >= 0) return a; r = -(i + s) } var u = 33306690738754716e-32 * r; return a >= u || a <= -u ? a : o(t, e, n) }, function (t, e, n, r) { var i = t[0] - r[0], o = e[0] - r[0], a = n[0] - r[0], u = t[1] - r[1], l = e[1] - r[1], c = n[1] - r[1], h = t[2] - r[2], p = e[2] - r[2], f = n[2] - r[2], g = o * c, d = a * l, y = a * u, v = i * c, _ = i * l, m = o * u, x = h * (g - d) + p * (y - v) + f * (_ - m), E = 7771561172376103e-31 * ((Math.abs(g) + Math.abs(d)) * Math.abs(h) + (Math.abs(y) + Math.abs(v)) * Math.abs(p) + (Math.abs(_) + Math.abs(m)) * Math.abs(f)); return x > E || -x > E ? x : s(t, e, n, r) }]; function u(t) { var e = a[t.length]; return e || (e = a[t.length] = i(t.length)), e.apply(void 0, t) } !function () { for (; a.length <= 5;)a.push(i(a.length)); for (var e = [], n = ["slow"], r = 0; r <= 5; ++r)e.push("a" + r), n.push("o" + r); var o = ["function getOrientation(", e.join(), "){switch(arguments.length){case 0:case 1:return 0;"]; for (r = 2; r <= 5; ++r)o.push("case ", r, ":return o", r, "(", e.slice(0, r).join(), ");"); o.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation"), n.push(o.join("")); var s = Function.apply(void 0, n); for (t.exports = s.apply(void 0, [u].concat(a)), r = 0; r <= 5; ++r)t.exports[r] = a[r] }() })), Wt = function (t) { var e = t.length; if (e < 3) { for (var n = new Array(e), r = 0; r < e; ++r)n[r] = r; return 2 === e && t[0][0] === t[1][0] && t[0][1] === t[1][1] ? [0] : n } var i = new Array(e); for (r = 0; r < e; ++r)i[r] = r; i.sort((function (e, n) { var r = t[e][0] - t[n][0]; return r || t[e][1] - t[n][1] })); var o = [i[0], i[1]], s = [i[0], i[1]]; for (r = 2; r < e; ++r) { for (var a = i[r], u = t[a], l = o.length; l > 1 && Jt(t[o[l - 2]], t[o[l - 1]], u) <= 0;)l -= 1, o.pop(); for (o.push(a), l = s.length; l > 1 && Jt(t[s[l - 2]], t[s[l - 1]], u) >= 0;)l -= 1, s.pop(); s.push(a) } n = new Array(s.length + o.length - 2); for (var c = 0, h = (r = 0, o.length); r < h; ++r)n[c++] = o[r]; for (var p = s.length - 2; p > 0; --p)n[c++] = s[p]; return n }, Jt = Ht[3]; var Zt = Qt, Kt = Qt; function Qt(t, e) { if (!(this instanceof Qt)) return new Qt(t, e); if (this.data = t || [], this.length = this.data.length, this.compare = e || $t, this.length > 0) for (var n = (this.length >> 1) - 1; n >= 0; n--)this._down(n) } function $t(t, e) { return t < e ? -1 : t > e ? 1 : 0 } Qt.prototype = { push: function (t) { this.data.push(t), this.length++, this._up(this.length - 1) }, pop: function () { if (0 !== this.length) { var t = this.data[0]; return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t } }, peek: function () { return this.data[0] }, _up: function (t) { for (var e = this.data, n = this.compare, r = e[t]; t > 0;) { var i = t - 1 >> 1, o = e[i]; if (n(r, o) >= 0) break; e[t] = o, t = i } e[t] = r }, _down: function (t) { for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) { var o = 1 + (t << 1), s = o + 1, a = e[o]; if (s < this.length && n(e[s], a) < 0 && (o = s, a = e[s]), n(a, i) >= 0) break; e[t] = a, t = o } e[t] = i } }, Zt.default = Kt; var te = function (t, e) { for (var n = t[0], r = t[1], i = !1, o = 0, s = e.length - 1; o < e.length; s = o++) { var a = e[o][0], u = e[o][1], l = e[s][0], c = e[s][1]; u > r != c > r && n < (l - a) * (r - u) / (c - u) + a && (i = !i) } return i }, ee = Ht[3], ne = ie, re = ie; function ie(t, e, n) { e = Math.max(0, void 0 === e ? 2 : e), n = n || 0; for (var r, i = function (t) { for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) { var s = t[o]; s[0] < e[0] && (e = s), s[0] > r[0] && (r = s), s[1] < n[1] && (n = s), s[1] > i[1] && (i = s) } var a = [e, n, r, i], u = a.slice(); for (o = 0; o < t.length; o++)te(t[o], a) || u.push(t[o]); var l = Wt(u), c = []; for (o = 0; o < l.length; o++)c.push(u[l[o]]); return c }(t), o = Nt(16, ["[0]", "[1]", "[0]", "[1]"]).load(t), s = [], a = 0; a < i.length; a++) { var u = i[a]; o.remove(u), r = he(u, r), s.push(r) } var l = Nt(16); for (a = 0; a < s.length; a++)l.insert(ce(s[a])); for (var c = e * e, h = n * n; s.length;) { var p = s.shift(), f = p.p, g = p.next.p, d = pe(f, g); if (!(d < h)) { var y = d / c; (u = oe(o, p.prev.p, f, g, p.next.next.p, y, l)) && Math.min(pe(u, f), pe(u, g)) <= y && (s.push(p), s.push(he(u, p)), o.remove(u), l.remove(p), l.insert(ce(p)), l.insert(ce(p.next))) } } p = r; var v = []; do { v.push(p.p), p = p.next } while (p !== r); return v.push(p.p), v } function oe(t, e, n, r, i, o, s) { for (var a = new Zt(null, se), u = t.data; u;) { for (var l = 0; l < u.children.length; l++) { var c = u.children[l], h = u.leaf ? fe(c, n, r) : ae(n, r, c); h > o || a.push({ node: c, dist: h }) } for (; a.length && !a.peek().node.children;) { var p = a.pop(), f = p.node, g = fe(f, e, n), d = fe(f, r, i); if (p.dist < g && p.dist < d && le(n, f, s) && le(r, f, s)) return f } (u = a.pop()) && (u = u.node) } return null } function se(t, e) { return t.dist - e.dist } function ae(t, e, n) { if (ue(t, n) || ue(e, n)) return 0; var r = ge(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY); if (0 === r) return 0; var i = ge(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY); if (0 === i) return 0; var o = ge(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY); if (0 === o) return 0; var s = ge(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY); return 0 === s ? 0 : Math.min(r, i, o, s) } function ue(t, e) { return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY } function le(t, e, n) { for (var r, i, o, s, a = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), l = Math.max(t[0], e[0]), c = Math.max(t[1], e[1]), h = n.search({ minX: a, minY: u, maxX: l, maxY: c }), p = 0; p < h.length; p++)if (r = h[p].p, i = h[p].next.p, o = t, r !== (s = e) && i !== o && ee(r, i, o) > 0 != ee(r, i, s) > 0 && ee(o, s, r) > 0 != ee(o, s, i) > 0) return !1; return !0 } function ce(t) { var e = t.p, n = t.next.p; return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t } function he(t, e) { var n = { p: t, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0 }; return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n } function pe(t, e) { var n = t[0] - e[0], r = t[1] - e[1]; return n * n + r * r } function fe(t, e, n) { var r = e[0], i = e[1], o = n[0] - r, s = n[1] - i; if (0 !== o || 0 !== s) { var a = ((t[0] - r) * o + (t[1] - i) * s) / (o * o + s * s); a > 1 ? (r = n[0], i = n[1]) : a > 0 && (r += o * a, i += s * a) } return (o = t[0] - r) * o + (s = t[1] - i) * s } function ge(t, e, n, r, i, o, s, a) { var u, l, c, h, p = n - t, f = r - e, g = s - i, d = a - o, y = t - i, v = e - o, _ = p * p + f * f, m = p * g + f * d, x = g * g + d * d, E = p * y + f * v, b = g * y + d * v, w = _ * x - m * m, I = w, N = w; 0 === w ? (l = 0, I = 1, h = b, N = x) : (h = _ * b - m * E, (l = m * b - x * E) < 0 ? (l = 0, h = b, N = x) : l > I && (l = I, h = b + m, N = x)), h < 0 ? (h = 0, -E < 0 ? l = 0 : -E > _ ? l = I : (l = -E, I = _)) : h > N && (h = N, -E + m < 0 ? l = 0 : -E + m > _ ? l = I : (l = -E + m, I = _)); var S = (1 - (c = 0 === h ? 0 : h / N)) * i + c * s - ((1 - (u = 0 === l ? 0 : l / I)) * t + u * n), C = (1 - c) * o + c * a - ((1 - u) * e + u * r); return S * S + C * C } function de(t, e) { void 0 === e && (e = {}), e.concavity = e.concavity || 1 / 0; var n = []; if (z(t, (function (t) { n.push([t[0], t[1]]) })), !n.length) return null; var r = ne(n, e.concavity); return r.length > 3 ? l([r]) : null } function ye(t, e, n) { if (void 0 === n && (n = {}), !t) throw new Error("point is required"); if (!e) throw new Error("polygon is required"); var r = R(t), i = G(e), o = i.type, s = e.bbox, a = i.coordinates; if (s && !1 === function (t, e) { return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1] }(r, s)) return !1; "Polygon" === o && (a = [a]); for (var u = !1, l = 0; l < a.length && !u; l++)if (ve(r, a[l][0], n.ignoreBoundary)) { for (var c = !1, h = 1; h < a[l].length && !c;)ve(r, a[l][h], !n.ignoreBoundary) && (c = !0), h++; c || (u = !0) } return u } function ve(t, e, n) { var r = !1; e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1)); for (var i = 0, o = e.length - 1; i < e.length; o = i++) { var s = e[i][0], a = e[i][1], u = e[o][0], l = e[o][1]; if (t[1] * (s - u) + a * (u - t[0]) + l * (t[0] - s) == 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (l - t[1]) <= 0) return !n; a > t[1] != l > t[1] && t[0] < (u - s) * (t[1] - a) / (l - a) + s && (r = !r) } return r } function _e(t, e) { var n = []; return X(t, (function (t) { var r = !1; W(e, (function (e) { ye(t, e) && (r = !0) })), r && n.push(t) })), f(n) } function me(t, e, n) { void 0 === n && (n = {}); var r = R(t), i = R(e), o = I(i[1] - r[1]), s = I(i[0] - r[0]), a = I(r[1]), u = I(i[1]), l = Math.pow(Math.sin(o / 2), 2) + Math.pow(Math.sin(s / 2), 2) * Math.cos(a) * Math.cos(u); return m(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), n.units) } function xe(t, e) { var n = !1; return f(function (t) { if (t.length < 3) return []; t.sort(be); var e, n, r, i, o, s, a = t.length - 1, u = t[a].x, l = t[0].x, c = t[a].y, h = c, p = 1e-12; for (; a--;)t[a].y < c && (c = t[a].y), t[a].y > h && (h = t[a].y); var f, g = l - u, d = h - c, y = g > d ? g : d, v = .5 * (l + u), _ = .5 * (h + c), m = [new Ee({ __sentinel: !0, x: v - 20 * y, y: _ - y }, { __sentinel: !0, x: v, y: _ + 20 * y }, { __sentinel: !0, x: v + 20 * y, y: _ - y })], x = [], E = []; a = t.length; for (; a--;) { for (E.length = 0, f = m.length; f--;)(g = t[a].x - m[f].x) > 0 && g * g > m[f].r ? (x.push(m[f]), m.splice(f, 1)) : g * g + (d = t[a].y - m[f].y) * d > m[f].r || (E.push(m[f].a, m[f].b, m[f].b, m[f].c, m[f].c, m[f].a), m.splice(f, 1)); for (we(E), f = E.length; f;)n = E[--f], e = E[--f], r = t[a], i = n.x - e.x, o = n.y - e.y, s = 2 * (i * (r.y - n.y) - o * (r.x - n.x)), Math.abs(s) > p && m.push(new Ee(e, n, r)) } Array.prototype.push.apply(x, m), a = x.length; for (; a--;)(x[a].a.__sentinel || x[a].b.__sentinel || x[a].c.__sentinel) && x.splice(a, 1); return x }(t.features.map((function (t) { var r = { x: t.geometry.coordinates[0], y: t.geometry.coordinates[1] }; return e ? r.z = t.properties[e] : 3 === t.geometry.coordinates.length && (n = !0, r.z = t.geometry.coordinates[2]), r }))).map((function (t) { var e = [t.a.x, t.a.y], r = [t.b.x, t.b.y], i = [t.c.x, t.c.y], o = {}; return n ? (e.push(t.a.z), r.push(t.b.z), i.push(t.c.z)) : o = { a: t.a.z, b: t.b.z, c: t.c.z }, l([[e, r, i, e]], o) }))) } ne.default = re; var Ee = function (t, e, n) { this.a = t, this.b = e, this.c = n; var r, i, o = e.x - t.x, s = e.y - t.y, a = n.x - t.x, u = n.y - t.y, l = o * (t.x + e.x) + s * (t.y + e.y), c = a * (t.x + n.x) + u * (t.y + n.y), h = 2 * (o * (n.y - e.y) - s * (n.x - e.x)); this.x = (u * l - s * c) / h, this.y = (o * c - a * l) / h, r = this.x - t.x, i = this.y - t.y, this.r = r * r + i * i }; function be(t, e) { return e.x - t.x } function we(t) { var e, n, r, i, o, s = t.length; t: for (; s;)for (n = t[--s], e = t[--s], r = s; r;)if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) { t.splice(s, 2), t.splice(r, 2), s -= 2; continue t } } function Ie(t) { if (!t) throw new Error("geojson is required"); switch (t.type) { case "Feature": return Ne(t); case "FeatureCollection": return function (t) { var e = { type: "FeatureCollection" }; return Object.keys(t).forEach((function (n) { switch (n) { case "type": case "features": return; default: e[n] = t[n] } })), e.features = t.features.map((function (t) { return Ne(t) })), e }(t); case "Point": case "LineString": case "Polygon": case "MultiPoint": case "MultiLineString": case "MultiPolygon": case "GeometryCollection": return Ce(t); default: throw new Error("unknown GeoJSON type") } } function Ne(t) { var e = { type: "Feature" }; return Object.keys(t).forEach((function (n) { switch (n) { case "type": case "properties": case "geometry": return; default: e[n] = t[n] } })), e.properties = Se(t.properties), e.geometry = Ce(t.geometry), e } function Se(t) { var e = {}; return t ? (Object.keys(t).forEach((function (n) { var r = t[n]; "object" == typeof r ? null === r ? e[n] = null : Array.isArray(r) ? e[n] = r.map((function (t) { return t })) : e[n] = Se(r) : e[n] = r })), e) : e } function Ce(t) { var e = { type: t.type }; return t.bbox && (e.bbox = t.bbox), "GeometryCollection" === t.type ? (e.geometries = t.geometries.map((function (t) { return Ce(t) })), e) : (e.coordinates = Pe(t.coordinates), e) } function Pe(t) { var e = t; return "object" != typeof e[0] ? e.slice() : e.map((function (t) { return Pe(t) })) } function Le(t, e) { if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error("options is invalid"); var n = e.mutate; if ("FeatureCollection" !== q(t)) throw new Error("geojson must be a FeatureCollection"); if (!t.features.length) throw new Error("geojson is empty"); !1 !== n && void 0 !== n || (t = Ie(t)); var r = [], i = et(t, (function (t, e) { var n = function (t, e) { var n, r = t.geometry.coordinates, i = e.geometry.coordinates, o = Me(r[0]), s = Me(r[r.length - 1]), a = Me(i[0]), u = Me(i[i.length - 1]); if (o === u) n = i.concat(r.slice(1)); else if (a === s) n = r.concat(i.slice(1)); else if (o === a) n = r.slice(1).reverse().concat(i); else { if (s !== u) return null; n = r.concat(i.reverse().slice(1)) } return h(n) }(t, e); return n || (r.push(t), e) })); return i && r.push(i), r.length ? 1 === r.length ? r[0] : g(r.map((function (t) { return t.coordinates }))) : null } function Me(t) { return t[0].toString() + "," + t[1].toString() } function Oe(t) { return t } function Re(t, e) { var n = function (t) { if (null == t) return Oe; var e, n, r = t.scale[0], i = t.scale[1], o = t.translate[0], s = t.translate[1]; return function (t, a) { a || (e = n = 0); var u = 2, l = t.length, c = new Array(l); for (c[0] = (e += t[0]) * r + o, c[1] = (n += t[1]) * i + s; u < l;)c[u] = t[u], ++u; return c } }(t.transform), r = t.arcs; function i(t, e) { e.length && e.pop(); for (var i = r[t < 0 ? ~t : t], o = 0, s = i.length; o < s; ++o)e.push(n(i[o], o)); t < 0 && function (t, e) { for (var n, r = t.length, i = r - e; i < --r;)n = t[i], t[i++] = t[r], t[r] = n }(e, s) } function o(t) { return n(t) } function s(t) { for (var e = [], n = 0, r = t.length; n < r; ++n)i(t[n], e); return e.length < 2 && e.push(e[0]), e } function a(t) { for (var e = s(t); e.length < 4;)e.push(e[0]); return e } function u(t) { return t.map(a) } return function t(e) { var n, r = e.type; switch (r) { case "GeometryCollection": return { type: r, geometries: e.geometries.map(t) }; case "Point": n = o(e.coordinates); break; case "MultiPoint": n = e.coordinates.map(o); break; case "LineString": n = s(e.arcs); break; case "MultiLineString": n = e.arcs.map(s); break; case "Polygon": n = u(e.arcs); break; case "MultiPolygon": n = e.arcs.map(u); break; default: return null }return { type: r, coordinates: n } }(e) } function Te(t, e) { var n = {}, r = {}, i = {}, o = [], s = -1; function a(t, e) { for (var r in t) { var i = t[r]; delete e[i.start], delete i.start, delete i.end, i.forEach((function (t) { n[t < 0 ? ~t : t] = 1 })), o.push(i) } } return e.forEach((function (n, r) { var i, o = t.arcs[n < 0 ? ~n : n]; o.length < 3 && !o[1][0] && !o[1][1] && (i = e[++s], e[s] = n, e[r] = i) })), e.forEach((function (e) { var n, o, s = function (e) { var n, r = t.arcs[e < 0 ? ~e : e], i = r[0]; t.transform ? (n = [0, 0], r.forEach((function (t) { n[0] += t[0], n[1] += t[1] }))) : n = r[r.length - 1]; return e < 0 ? [n, i] : [i, n] }(e), a = s[0], u = s[1]; if (n = i[a]) if (delete i[n.end], n.push(e), n.end = u, o = r[u]) { delete r[o.start]; var l = o === n ? n : n.concat(o); r[l.start = n.start] = i[l.end = o.end] = l } else r[n.start] = i[n.end] = n; else if (n = r[u]) if (delete r[n.start], n.unshift(e), n.start = a, o = i[a]) { delete i[o.end]; var c = o === n ? n : o.concat(n); r[c.start = o.start] = i[c.end = n.end] = c } else r[n.start] = i[n.end] = n; else r[(n = [e]).start = a] = i[n.end = u] = n })), a(i, r), a(r, i), e.forEach((function (t) { n[t < 0 ? ~t : t] || o.push([t]) })), o } function Ae(t, e) { var n = {}, r = [], i = []; function o(t) { t.forEach((function (e) { e.forEach((function (e) { (n[e = e < 0 ? ~e : e] || (n[e] = [])).push(t) })) })), r.push(t) } function s(e) { return function (t) { for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;)e = i, i = t[n], o += e[0] * i[1] - e[1] * i[0]; return Math.abs(o) }(Re(t, { type: "Polygon", arcs: [e] }).coordinates[0]) } return e.forEach((function t(e) { switch (e.type) { case "GeometryCollection": e.geometries.forEach(t); break; case "Polygon": o(e.arcs); break; case "MultiPolygon": e.arcs.forEach(o) } })), r.forEach((function (t) { if (!t._) { var e = [], r = [t]; for (t._ = 1, i.push(e); t = r.pop();)e.push(t), t.forEach((function (t) { t.forEach((function (t) { n[t < 0 ? ~t : t].forEach((function (t) { t._ || (t._ = 1, r.push(t)) })) })) })) } })), r.forEach((function (t) { delete t._ })), { type: "MultiPolygon", arcs: i.map((function (e) { var r, i = []; if (e.forEach((function (t) { t.forEach((function (t) { t.forEach((function (t) { n[t < 0 ? ~t : t].length < 2 && i.push(t) })) })) })), (r = (i = Te(t, i)).length) > 1) for (var o, a, u = 1, l = s(i[0]); u < r; ++u)(o = s(i[u])) > l && (a = i[0], i[0] = i[u], i[u] = a, l = o); return i })) } } function De(t, e, n, r, i, o) { 3 === arguments.length && (r = o = Array, i = null); for (var s = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = new o(t), u = t - 1, l = 0; l < t; ++l)s[l] = i; function c(r, o) { for (var l = e(r) & u, c = s[l], h = 0; c != i;) { if (n(c, r)) return a[l] = o; if (++h >= t) throw new Error("full hashmap"); c = s[l = l + 1 & u] } return s[l] = r, a[l] = o, o } function h(r, o) { for (var l = e(r) & u, c = s[l], h = 0; c != i;) { if (n(c, r)) return a[l]; if (++h >= t) throw new Error("full hashmap"); c = s[l = l + 1 & u] } return s[l] = r, a[l] = o, o } function p(r, o) { for (var l = e(r) & u, c = s[l], h = 0; c != i;) { if (n(c, r)) return a[l]; if (++h >= t) break; c = s[l = l + 1 & u] } return o } function f() { for (var t = [], e = 0, n = s.length; e < n; ++e) { var r = s[e]; r != i && t.push(r) } return t } return { set: c, maybeSet: h, get: p, keys: f } } function Fe(t, e) { return t[0] === e[0] && t[1] === e[1] } var ke = new ArrayBuffer(16), Ge = new Float64Array(ke), qe = new Uint32Array(ke); function Be(t) { Ge[0] = t[0], Ge[1] = t[1]; var e = qe[0] ^ qe[1]; return 2147483647 & (e = e << 5 ^ e >> 7 ^ qe[2] ^ qe[3]) } function ze(t) { var e, n, r, i, o = t.coordinates, s = t.lines, a = t.rings, u = function () { for (var t = De(1.4 * o.length, E, b, Int32Array, -1, Int32Array), e = new Int32Array(o.length), n = 0, r = o.length; n < r; ++n)e[n] = t.maybeSet(n, n); return e }(), l = new Int32Array(o.length), c = new Int32Array(o.length), h = new Int32Array(o.length), p = new Int8Array(o.length), f = 0; for (e = 0, n = o.length; e < n; ++e)l[e] = c[e] = h[e] = -1; for (e = 0, n = s.length; e < n; ++e) { var g = s[e], d = g[0], y = g[1]; for (r = u[d], i = u[++d], ++f, p[r] = 1; ++d <= y;)x(e, r, r = i, i = u[d]); ++f, p[i] = 1 } for (e = 0, n = o.length; e < n; ++e)l[e] = -1; for (e = 0, n = a.length; e < n; ++e) { var v = a[e], _ = v[0] + 1, m = v[1]; for (x(e, u[m - 1], r = u[_ - 1], i = u[_]); ++_ <= m;)x(e, r, r = i, i = u[_]) } function x(t, e, n, r) { if (l[n] !== t) { l[n] = t; var i = c[n]; if (i >= 0) { var o = h[n]; i === e && o === r || i === r && o === e || (++f, p[n] = 1) } else c[n] = e, h[n] = r } } function E(t) { return Be(o[t]) } function b(t, e) { return Fe(o[t], o[e]) } l = c = h = null; var w, I = function (t, e, n, r, i) { 3 === arguments.length && (r = Array, i = null); for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), s = t - 1, a = 0; a < t; ++a)o[a] = i; function u(r) { for (var a = e(r) & s, u = o[a], l = 0; u != i;) { if (n(u, r)) return !0; if (++l >= t) throw new Error("full hashset"); u = o[a = a + 1 & s] } return o[a] = r, !0 } function l(r) { for (var a = e(r) & s, u = o[a], l = 0; u != i;) { if (n(u, r)) return !0; if (++l >= t) break; u = o[a = a + 1 & s] } return !1 } function c() { for (var t = [], e = 0, n = o.length; e < n; ++e) { var r = o[e]; r != i && t.push(r) } return t } return { add: u, has: l, values: c } }(1.4 * f, Be, Fe); for (e = 0, n = o.length; e < n; ++e)p[w = u[e]] && I.add(o[w]); return I } function je(t, e, n, r) { Ue(t, e, n), Ue(t, e, e + r), Ue(t, e + r, n) } function Ue(t, e, n) { for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n)r = t[e], t[e] = t[n], t[n] = r } function Ve(t) { var e, n, r = {}; for (e in t) r[e] = null == (n = t[e]) ? { type: null } : ("FeatureCollection" === n.type ? Xe : "Feature" === n.type ? Ye : He)(n); return r } function Xe(t) { var e = { type: "GeometryCollection", geometries: t.features.map(Ye) }; return null != t.bbox && (e.bbox = t.bbox), e } function Ye(t) { var e, n = He(t.geometry); for (e in null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties) { n.properties = t.properties; break } return n } function He(t) { if (null == t) return { type: null }; var e = "GeometryCollection" === t.type ? { type: "GeometryCollection", geometries: t.geometries.map(He) } : "Point" === t.type || "MultiPoint" === t.type ? { type: t.type, coordinates: t.coordinates } : { type: t.type, arcs: t.coordinates }; return null != t.bbox && (e.bbox = t.bbox), e } function We(t, e) { var n = function (t) { var e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0; function o(t) { null != t && s.hasOwnProperty(t.type) && s[t.type](t) } var s = { GeometryCollection: function (t) { t.geometries.forEach(o) }, Point: function (t) { a(t.coordinates) }, MultiPoint: function (t) { t.coordinates.forEach(a) }, LineString: function (t) { u(t.arcs) }, MultiLineString: function (t) { t.arcs.forEach(u) }, Polygon: function (t) { t.arcs.forEach(u) }, MultiPolygon: function (t) { t.arcs.forEach(l) } }; function a(t) { var o = t[0], s = t[1]; o < e && (e = o), o > r && (r = o), s < n && (n = s), s > i && (i = s) } function u(t) { t.forEach(a) } function l(t) { t.forEach(u) } for (var c in t) o(t[c]); return r >= e && i >= n ? [e, n, r, i] : void 0 }(t = Ve(t)), r = e > 0 && n && function (t, e, n) { var r = e[0], i = e[1], o = e[2], s = e[3], a = o - r ? (n - 1) / (o - r) : 1, u = s - i ? (n - 1) / (s - i) : 1; function l(t) { return [Math.round((t[0] - r) * a), Math.round((t[1] - i) * u)] } function c(t, e) { for (var n, o, s, l, c, h = -1, p = 0, f = t.length, g = new Array(f); ++h < f;)n = t[h], l = Math.round((n[0] - r) * a), c = Math.round((n[1] - i) * u), l === o && c === s || (g[p++] = [o = l, s = c]); for (g.length = p; p < e;)p = g.push([g[0][0], g[0][1]]); return g } function h(t) { return c(t, 2) } function p(t) { return c(t, 4) } function f(t) { return t.map(p) } function g(t) { null != t && d.hasOwnProperty(t.type) && d[t.type](t) } var d = { GeometryCollection: function (t) { t.geometries.forEach(g) }, Point: function (t) { t.coordinates = l(t.coordinates) }, MultiPoint: function (t) { t.coordinates = t.coordinates.map(l) }, LineString: function (t) { t.arcs = h(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(h) }, Polygon: function (t) { t.arcs = f(t.arcs) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(f) } }; for (var y in t) g(t[y]); return { scale: [1 / a, 1 / u], translate: [r, i] } }(t, n, e), i = function (t) { var e, n, r, i, o = t.coordinates, s = t.lines, a = t.rings, u = s.length + a.length; for (delete t.lines, delete t.rings, r = 0, i = s.length; r < i; ++r)for (e = s[r]; e = e.next;)++u; for (r = 0, i = a.length; r < i; ++r)for (n = a[r]; n = n.next;)++u; var l = De(2 * u * 1.4, Be, Fe), c = t.arcs = []; for (r = 0, i = s.length; r < i; ++r) { e = s[r]; do { h(e) } while (e = e.next) } for (r = 0, i = a.length; r < i; ++r)if ((n = a[r]).next) do { h(n) } while (n = n.next); else p(n); function h(t) { var e, n, r, i, s, a, u, h; if (r = l.get(e = o[t[0]])) for (u = 0, h = r.length; u < h; ++u)if (f(i = r[u], t)) return t[0] = i[0], void (t[1] = i[1]); if (s = l.get(n = o[t[1]])) for (u = 0, h = s.length; u < h; ++u)if (g(a = s[u], t)) return t[1] = a[0], void (t[0] = a[1]); r ? r.push(t) : l.set(e, [t]), s ? s.push(t) : l.set(n, [t]), c.push(t) } function p(t) { var e, n, r, i, s; if (n = l.get(o[t[0]])) for (i = 0, s = n.length; i < s; ++i) { if (d(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]); if (y(r, t)) return t[0] = r[1], void (t[1] = r[0]) } if (n = l.get(e = o[t[0] + v(t)])) for (i = 0, s = n.length; i < s; ++i) { if (d(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]); if (y(r, t)) return t[0] = r[1], void (t[1] = r[0]) } n ? n.push(t) : l.set(e, [t]), c.push(t) } function f(t, e) { var n = t[0], r = e[0], i = t[1]; if (n - i != r - e[1]) return !1; for (; n <= i; ++n, ++r)if (!Fe(o[n], o[r])) return !1; return !0 } function g(t, e) { var n = t[0], r = e[0], i = t[1], s = e[1]; if (n - i != r - s) return !1; for (; n <= i; ++n, --s)if (!Fe(o[n], o[s])) return !1; return !0 } function d(t, e) { var n = t[0], r = e[0], i = t[1] - n; if (i !== e[1] - r) return !1; for (var s = v(t), a = v(e), u = 0; u < i; ++u)if (!Fe(o[n + (u + s) % i], o[r + (u + a) % i])) return !1; return !0 } function y(t, e) { var n = t[0], r = e[0], i = t[1], s = e[1], a = i - n; if (a !== s - r) return !1; for (var u = v(t), l = a - v(e), c = 0; c < a; ++c)if (!Fe(o[n + (c + u) % a], o[s - (c + l) % a])) return !1; return !0 } function v(t) { for (var e = t[0], n = t[1], r = e, i = r, s = o[r]; ++r < n;) { var a = o[r]; (a[0] < s[0] || a[0] === s[0] && a[1] < s[1]) && (i = r, s = a) } return i - e } return t }(function (t) { var e, n, r, i = ze(t), o = t.coordinates, s = t.lines, a = t.rings; for (n = 0, r = s.length; n < r; ++n)for (var u = s[n], l = u[0], c = u[1]; ++l < c;)i.has(o[l]) && (e = { 0: l, 1: u[1] }, u[1] = l, u = u.next = e); for (n = 0, r = a.length; n < r; ++n)for (var h = a[n], p = h[0], f = p, g = h[1], d = i.has(o[p]); ++f < g;)i.has(o[f]) && (d ? (e = { 0: f, 1: h[1] }, h[1] = f, h = h.next = e) : (je(o, p, g, g - f), o[g] = o[p], d = !0, f = p)); return t }(function (t) { var e = -1, n = [], r = [], i = []; function o(t) { t && s.hasOwnProperty(t.type) && s[t.type](t) } var s = { GeometryCollection: function (t) { t.geometries.forEach(o) }, LineString: function (t) { t.arcs = a(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(a) }, Polygon: function (t) { t.arcs = t.arcs.map(u) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(l) } }; function a(t) { for (var r = 0, o = t.length; r < o; ++r)i[++e] = t[r]; var s = { 0: e - o + 1, 1: e }; return n.push(s), s } function u(t) { for (var n = 0, o = t.length; n < o; ++n)i[++e] = t[n]; var s = { 0: e - o + 1, 1: e }; return r.push(s), s } function l(t) { return t.map(u) } for (var c in t) o(t[c]); return { type: "Topology", coordinates: i, lines: n, rings: r, objects: t } }(t))), o = i.coordinates, s = De(1.4 * i.arcs.length, Je, Ze); function a(t) { t && u.hasOwnProperty(t.type) && u[t.type](t) } t = i.objects, i.bbox = n, i.arcs = i.arcs.map((function (t, e) { return s.set(t, e), o.slice(t[0], t[1] + 1) })), delete i.coordinates, o = null; var u = { GeometryCollection: function (t) { t.geometries.forEach(a) }, LineString: function (t) { t.arcs = l(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(l) }, Polygon: function (t) { t.arcs = t.arcs.map(l) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(c) } }; function l(t) { var e = []; do { var n = s.get(t); e.push(t[0] < t[1] ? n : ~n) } while (t = t.next); return e } function c(t) { return t.map(l) } for (var h in t) a(t[h]); return r && (i.transform = r, i.arcs = function (t) { for (var e = -1, n = t.length; ++e < n;) { for (var r, i, o = t[e], s = 0, a = 1, u = o.length, l = o[0], c = l[0], h = l[1]; ++s < u;)r = (l = o[s])[0], i = l[1], r === c && i === h || (o[a++] = [r - c, i - h], c = r, h = i); 1 === a && (o[a++] = [0, 0]), o.length = a } return t }(i.arcs)), i } function Je(t) { var e, n = t[0], r = t[1]; return r < n && (e = n, n = r, r = e), n + 31 * r } function Ze(t, e) { var n, r = t[0], i = t[1], o = e[0], s = e[1]; return i < r && (n = r, r = i, i = n), s < o && (n = o, o = s, s = n), r === o && i === s } function Ke(t, e) { if (void 0 === e && (e = {}), "FeatureCollection" !== q(t)) throw new Error("geojson must be a FeatureCollection"); if (!t.features.length) throw new Error("geojson is empty"); !1 !== e.mutate && void 0 !== e.mutate || (t = Ie(t)); var n = []; Z(t, (function (t) { n.push(t.geometry) })); var r = We({ geoms: v(n).geometry }); return function (t) { return Re(t, Ae.apply(this, arguments)) }(r, r.objects.geoms.geometries) } function Qe(t, e) { if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error("options is invalid"); var n = e.mutate; if ("FeatureCollection" !== q(t)) throw new Error("geojson must be a FeatureCollection"); if (!t.features.length) throw new Error("geojson is empty"); !1 !== n && void 0 !== n || (t = Ie(t)); var r = function (t) { var e = {}; Z(t, (function (t) { e[t.geometry.type] = !0 })); var n = Object.keys(e); if (1 === n.length) return n[0]; return null }(t); if (!r) throw new Error("geojson must be homogenous"); var i = t; switch (r) { case "LineString": return Le(i, e); case "Polygon": return Ke(i, e); default: throw new Error(r + " is not supported") } } function $e(t, e) { void 0 === e && (e = {}); var n = "object" == typeof e ? e.mutate : e; if (!t) throw new Error("geojson is required"); var r = q(t), i = []; switch (r) { case "LineString": i = tn(t); break; case "MultiLineString": case "Polygon": T(t).forEach((function (t) { i.push(tn(t)) })); break; case "MultiPolygon": T(t).forEach((function (t) { var e = []; t.forEach((function (t) { e.push(tn(t)) })), i.push(e) })); break; case "Point": return t; case "MultiPoint": var s = {}; T(t).forEach((function (t) { var e = t.join("-"); s.hasOwnProperty(e) || (i.push(t), s[e] = !0) })); break; default: throw new Error(r + " geometry not supported") }return t.coordinates ? !0 === n ? (t.coordinates = i, t) : { type: r, coordinates: i } : !0 === n ? (t.geometry.coordinates = i, t) : o({ type: r, coordinates: i }, t.properties, { bbox: t.bbox, id: t.id }) } function tn(t) { var e = T(t); if (2 === e.length && !en(e[0], e[1])) return e; var n = [], r = e.length - 1, i = n.length; n.push(e[0]); for (var o = 1; o < r; o++) { var s = n[n.length - 1]; e[o][0] === s[0] && e[o][1] === s[1] || (n.push(e[o]), (i = n.length) > 2 && nn(n[i - 3], n[i - 1], n[i - 2]) && n.splice(n.length - 2, 1)) } if (n.push(e[e.length - 1]), i = n.length, en(e[0], e[e.length - 1]) && i < 4) throw new Error("invalid polygon"); return nn(n[i - 3], n[i - 1], n[i - 2]) && n.splice(n.length - 2, 1), n } function en(t, e) { return t[0] === e[0] && t[1] === e[1] } function nn(t, e, n) { var r = n[0], i = n[1], o = t[0], s = t[1], a = e[0], u = e[1], l = a - o, c = u - s; return 0 === (r - o) * c - (i - s) * l && (Math.abs(l) >= Math.abs(c) ? l > 0 ? o <= r && r <= a : a <= r && r <= o : c > 0 ? s <= i && i <= u : u <= i && i <= s) } function rn(t, e, n) { var r = e.x, i = e.y, o = n.x - r, s = n.y - i; if (0 !== o || 0 !== s) { var a = ((t.x - r) * o + (t.y - i) * s) / (o * o + s * s); a > 1 ? (r = n.x, i = n.y) : a > 0 && (r += o * a, i += s * a) } return (o = t.x - r) * o + (s = t.y - i) * s } function on(t, e, n, r, i) { for (var o, s = r, a = e + 1; a < n; a++) { var u = rn(t[a], t[e], t[n]); u > s && (o = a, s = u) } s > r && (o - e > 1 && on(t, e, o, r, i), i.push(t[o]), n - o > 1 && on(t, o, n, r, i)) } function sn(t, e) { var n = t.length - 1, r = [t[0]]; return on(t, 0, n, e, r), r.push(t[n]), r } function an(t, e, n) { if (t.length <= 2) return t; var r = void 0 !== e ? e * e : 1; return t = sn(t = n ? t : function (t, e) { for (var n, r, i, o, s, a = t[0], u = [a], l = 1, c = t.length; l < c; l++)n = t[l], i = a, o = void 0, s = void 0, o = (r = n).x - i.x, s = r.y - i.y, o * o + s * s > e && (u.push(n), a = n); return a !== n && u.push(n), u }(t, r), r) } function un(t, e, n) { return an(t.map((function (t) { return { x: t[0], y: t[1], z: t[2] } })), e, n).map((function (t) { return t.z ? [t.x, t.y, t.z] : [t.x, t.y] })) } function ln(t, e, n) { return t.map((function (t) { var r = t.map((function (t) { return { x: t[0], y: t[1] } })); if (r.length < 4) throw new Error("invalid polygon"); for (var i = an(r, e, n).map((function (t) { return [t.x, t.y] })); !cn(i);)i = an(r, e -= .01 * e, n).map((function (t) { return [t.x, t.y] })); return i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1] || i.push(i[0]), i })) } function cn(t) { return !(t.length < 3) && !(3 === t.length && t[2][0] === t[0][0] && t[2][1] === t[0][1]) } var hn = function () { function t(t) { this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0; for (var e = 0; e < this.length; e++)this.points[e].z = this.points[e].z || 0; for (e = 0; e < this.length - 1; e++) { var n = this.points[e], r = this.points[e + 1]; this.centers.push({ x: (n.x + r.x) / 2, y: (n.y + r.y) / 2, z: (n.z + r.z) / 2 }) } this.controls.push([this.points[0], this.points[0]]); for (e = 0; e < this.centers.length - 1; e++) { var i = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2, o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2, s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2; this.controls.push([{ x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + i), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s) }, { x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + i), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s) }]) } return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this } return t.prototype.cacheSteps = function (t) { var e = [], n = this.pos(0); e.push(0); for (var r = 0; r < this.duration; r += 10) { var i = this.pos(r); Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t && (e.push(r), n = i) } return e }, t.prototype.vector = function (t) { var e = this.pos(t + 10), n = this.pos(t - 10); return { angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14, speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z)) } }, t.prototype.pos = function (t) { var e = t - this.delay; e < 0 && (e = 0), e > this.duration && (e = this.duration - 1); var n = e / this.duration; if (n >= 1) return this.points[this.length - 1]; var r = Math.floor((this.points.length - 1) * n); return function (t, e, n, r, i) { var o = function (t) { var e = t * t; return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)] }(t); return { x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3], y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3], z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3] } }((this.length - 1) * n - r, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1]) }, t }(); function pn(t, e) { void 0 === e && (e = {}); for (var n = e.resolution || 1e4, r = e.sharpness || .85, i = [], o = G(t).coordinates.map((function (t) { return { x: t[0], y: t[1] } })), s = new hn({ duration: n, points: o, sharpness: r }), a = 0; a < s.duration; a += 10) { var u = s.pos(a); Math.floor(a / 100) % 2 == 0 && i.push([u.x, u.y]) } return h(i, e.properties) } function fn(t, e) { void 0 === e && (e = {}); var n = Number(t[0]), r = Number(t[1]), i = Number(t[2]), o = Number(t[3]); if (6 === t.length) throw new Error("@turf/bbox-polygon does not support BBox with 6 positions"); var s = [n, r]; return l([[s, [i, r], [i, o], [n, o], s]], e.properties, { bbox: t, id: e.id }) } function gn(t) { return fn(ot(t)) } function dn(t) { var e = t[0], n = t[1], r = t[2], i = t[3]; if (me(t.slice(0, 2), [r, n]) >= me(t.slice(0, 2), [e, i])) { var o = (n + i) / 2; return [e, o - (r - e) / 2, r, o + (r - e) / 2] } var s = (e + r) / 2; return [s - (i - n) / 2, n, s + (i - n) / 2, i] } function yn(t, e, n, r) { void 0 === r && (r = {}); var i = R(t), o = I(i[0]), s = I(i[1]), u = I(n), l = x(e, r.units), c = Math.asin(Math.sin(s) * Math.cos(l) + Math.cos(s) * Math.sin(l) * Math.cos(u)); return a([w(o + Math.atan2(Math.sin(u) * Math.sin(l) * Math.cos(s), Math.cos(l) - Math.sin(s) * Math.sin(c))), w(c)], r.properties) } function vn(t, e, n) { void 0 === n && (n = {}); for (var r = n.steps || 64, i = n.properties ? n.properties : !Array.isArray(t) && "Feature" === t.type && t.properties ? t.properties : {}, o = [], s = 0; s < r; s++)o.push(yn(t, e, -360 * s / r, n).geometry.coordinates); return o.push(o[0]), l([o], i) } function _n(t, e, n) { if (void 0 === n && (n = {}), !0 === n.final) return function (t, e) { var n = _n(e, t); return n = (n + 180) % 360 }(t, e); var r = R(t), i = R(e), o = I(r[0]), s = I(i[0]), a = I(r[1]), u = I(i[1]), l = Math.sin(s - o) * Math.cos(u), c = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(s - o); return w(Math.atan2(l, c)) } function mn(t, e) { void 0 === e && (e = {}); var n = ot(t); return a([(n[0] + n[2]) / 2, (n[1] + n[3]) / 2], e.properties, e) } function xn(t, e) { void 0 === e && (e = {}); var n = 0, r = 0, i = 0; return z(t, (function (t) { n += t[0], r += t[1], i++ }), !0), a([n / i, r / i], e.properties) } function En(t) { var e = []; return "FeatureCollection" === t.type ? X(t, (function (t) { z(t, (function (n) { e.push(a(n, t.properties)) })) })) : z(t, (function (n) { e.push(a(n, t.properties)) })), f(e) } var bn = In, wn = In; function In(t, e, n) { n = n || 2; var r, i, o, s, a, u, l, c = e && e.length, h = c ? e[0] * n : t.length, p = Nn(t, 0, h, n, !0), f = []; if (!p) return f; if (c && (p = function (t, e, n, r) { var i, o, s, a = []; for (i = 0, o = e.length; i < o; i++)(s = Nn(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === s.next && (s.steiner = !0), a.push(Dn(s)); for (a.sort(Rn), i = 0; i < a.length; i++)Tn(a[i], n), n = Sn(n, n.next); return n }(t, e, p, n)), t.length > 80 * n) { r = o = t[0], i = s = t[1]; for (var g = n; g < h; g += n)(a = t[g]) < r && (r = a), (u = t[g + 1]) < i && (i = u), a > o && (o = a), u > s && (s = u); l = 0 !== (l = Math.max(o - r, s - i)) ? 1 / l : 0 } return Cn(p, f, n, r, i, l), f } function Nn(t, e, n, r, i) { var o, s; if (i === Yn(t, e, n, r) > 0) for (o = e; o < n; o += r)s = Un(o, t[o], t[o + 1], s); else for (o = n - r; o >= e; o -= r)s = Un(o, t[o], t[o + 1], s); return s && qn(s, s.next) && (Vn(s), s = s.next), s } function Sn(t, e) { if (!t) return t; e || (e = t); var n, r = t; do { if (n = !1, r.steiner || !qn(r, r.next) && 0 !== Gn(r.prev, r, r.next)) r = r.next; else { if (Vn(r), (r = e = r.prev) === r.next) break; n = !0 } } while (n || r !== e); return e } function Cn(t, e, n, r, i, o, s) { if (t) { !s && o && function (t, e, n, r) { var i = t; do { null === i.z && (i.z = An(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { var e, n, r, i, o, s, a, u, l = 1; do { for (n = t, t = null, o = null, s = 0; n;) { for (s++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ); e++); for (u = l; a > 0 || u > 0 && r;)0 !== a && (0 === u || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i; n = r } o.nextZ = null, l *= 2 } while (s > 1) }(i) }(t, r, i, o); for (var a, u, l = t; t.prev !== t.next;)if (a = t.prev, u = t.next, o ? Ln(t, r, i, o) : Pn(t)) e.push(a.i / n), e.push(t.i / n), e.push(u.i / n), Vn(t), t = u.next, l = u.next; else if ((t = u) === l) { s ? 1 === s ? Cn(t = Mn(t, e, n), e, n, r, i, o, 2) : 2 === s && On(t, e, n, r, i, o) : Cn(Sn(t), e, n, r, i, o, 1); break } } } function Pn(t) { var e = t.prev, n = t, r = t.next; if (Gn(e, n, r) >= 0) return !1; for (var i = t.next.next; i !== t.prev;) { if (Fn(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Gn(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function Ln(t, e, n, r) { var i = t.prev, o = t, s = t.next; if (Gn(i, o, s) >= 0) return !1; for (var a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x, u = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y, l = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x, c = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, h = An(a, u, e, n, r), p = An(l, c, e, n, r), f = t.prevZ, g = t.nextZ; f && f.z >= h && g && g.z <= p;) { if (f !== t.prev && f !== t.next && Fn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && Gn(f.prev, f, f.next) >= 0) return !1; if (f = f.prevZ, g !== t.prev && g !== t.next && Fn(i.x, i.y, o.x, o.y, s.x, s.y, g.x, g.y) && Gn(g.prev, g, g.next) >= 0) return !1; g = g.nextZ } for (; f && f.z >= h;) { if (f !== t.prev && f !== t.next && Fn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && Gn(f.prev, f, f.next) >= 0) return !1; f = f.prevZ } for (; g && g.z <= p;) { if (g !== t.prev && g !== t.next && Fn(i.x, i.y, o.x, o.y, s.x, s.y, g.x, g.y) && Gn(g.prev, g, g.next) >= 0) return !1; g = g.nextZ } return !0 } function Mn(t, e, n) { var r = t; do { var i = r.prev, o = r.next.next; !qn(i, o) && Bn(i, r, r.next, o) && zn(i, o) && zn(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Vn(r), Vn(r.next), r = t = o), r = r.next } while (r !== t); return r } function On(t, e, n, r, i, o) { var s = t; do { for (var a = s.next.next; a !== s.prev;) { if (s.i !== a.i && kn(s, a)) { var u = jn(s, a); return s = Sn(s, s.next), u = Sn(u, u.next), Cn(s, e, n, r, i, o), void Cn(u, e, n, r, i, o) } a = a.next } s = s.next } while (s !== t) } function Rn(t, e) { return t.x - e.x } function Tn(t, e) { if (e = function (t, e) { var n, r = e, i = t.x, o = t.y, s = -1 / 0; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (a <= i && a > s) { if (s = a, a === i) { if (o === r.y) return r; if (o === r.next.y) return r.next } n = r.x < r.next.x ? r : r.next } } r = r.next } while (r !== e); if (!n) return null; if (i === s) return n.prev; var u, l = n, c = n.x, h = n.y, p = 1 / 0; r = n.next; for (; r !== l;)i >= r.x && r.x >= c && i !== r.x && Fn(o < h ? i : s, o, c, h, o < h ? s : i, o, r.x, r.y) && ((u = Math.abs(o - r.y) / (i - r.x)) < p || u === p && r.x > n.x) && zn(r, t) && (n = r, p = u), r = r.next; return n }(t, e)) { var n = jn(e, t); Sn(n, n.next) } } function An(t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function Dn(t) { var e = t, n = t; do { e.x < n.x && (n = e), e = e.next } while (e !== t); return n } function Fn(t, e, n, r, i, o, s, a) { return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0 } function kn(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Bn(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && zn(t, e) && zn(e, t) && function (t, e) { var n = t, r = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== t); return r }(t, e) } function Gn(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function qn(t, e) { return t.x === e.x && t.y === e.y } function Bn(t, e, n, r) { return !!(qn(t, e) && qn(n, r) || qn(t, r) && qn(n, e)) || Gn(t, e, n) > 0 != Gn(t, e, r) > 0 && Gn(n, r, t) > 0 != Gn(n, r, e) > 0 } function zn(t, e) { return Gn(t.prev, t, t.next) < 0 ? Gn(t, e, t.next) >= 0 && Gn(t, t.prev, e) >= 0 : Gn(t, e, t.prev) < 0 || Gn(t, t.next, e) < 0 } function jn(t, e) { var n = new Xn(t.i, t.x, t.y), r = new Xn(e.i, e.x, e.y), i = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r } function Un(t, e, n, r) { var i = new Xn(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function Vn(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Xn(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function Yn(t, e, n, r) { for (var i = 0, o = e, s = n - r; o < n; o += r)i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return i } function Hn(t) { var e = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (var o = 0; o < t[i].length; o++)for (var s = 0; s < e; s++)n.vertices.push(t[i][o][s]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n }(t), n = bn(e.vertices, e.holes, 2), r = [], i = []; n.forEach((function (t, r) { var o = n[r]; i.push([e.vertices[2 * o], e.vertices[2 * o + 1]]) })); for (var o = 0; o < i.length; o += 3) { var s = i.slice(o, o + 3); s.push(i[o]), r.push(l([s])) } return r } function Wn(t, e) { if (!t) throw new Error("targetPoint is required"); if (!e) throw new Error("points is required"); var n, r = 1 / 0, i = 0; return X(e, (function (e, n) { var o = me(t, e); o < r && (i = n, r = o) })), (n = Ie(e.features[i])).properties.featureIndex = i, n.properties.distanceToPoint = r, n } function Jn(t) { if (!t) throw new Error("geojson is required"); var e = []; return Z(t, (function (t) { !function (t, e) { var n = [], r = t.geometry; if (null !== r) { switch (r.type) { case "Polygon": n = T(r); break; case "LineString": n = [T(r)] }n.forEach((function (n) { (function (t, e) { var n = []; return t.reduce((function (t, r) { var i = h([t, r], e); return i.bbox = function (t, e) { var n = t[0], r = t[1], i = e[0], o = e[1]; return [n < i ? n : i, r < o ? r : o, n > i ? n : i, r > o ? r : o] }(t, r), n.push(i), r })), n })(n, t.properties).forEach((function (t) { t.id = e.length, e.push(t) })) })) } }(t, e) })), f(e) } In.deviation = function (t, e, n, r) { var i = e && e.length, o = i ? e[0] * n : t.length, s = Math.abs(Yn(t, 0, o, n)); if (i) for (var a = 0, u = e.length; a < u; a++) { var l = e[a] * n, c = a < u - 1 ? e[a + 1] * n : t.length; s -= Math.abs(Yn(t, l, c, n)) } var h = 0; for (a = 0; a < r.length; a += 3) { var p = r[a] * n, f = r[a + 1] * n, g = r[a + 2] * n; h += Math.abs((t[p] - t[g]) * (t[f + 1] - t[p + 1]) - (t[p] - t[f]) * (t[g + 1] - t[p + 1])) } return 0 === s && 0 === h ? 0 : Math.abs((h - s) / s) }, In.flatten = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (var o = 0; o < t[i].length; o++)for (var s = 0; s < e; s++)n.vertices.push(t[i][o][s]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n }, bn.default = wn; var Zn = Bt((function (t, e) { function n(t, e, n) { void 0 === n && (n = {}); var r = { type: "Feature" }; return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r } function r(t, e, r) { if (void 0 === r && (r = {}), !t) throw new Error("coordinates is required"); if (!Array.isArray(t)) throw new Error("coordinates must be an Array"); if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!f(t[0]) || !f(t[1])) throw new Error("coordinates must contain numbers"); return n({ type: "Point", coordinates: t }, e, r) } function i(t, e, r) { void 0 === r && (r = {}); for (var i = 0, o = t; i < o.length; i++) { var s = o[i]; if (s.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < s[s.length - 1].length; a++)if (s[s.length - 1][a] !== s[0][a]) throw new Error("First and last Position are not equivalent.") } return n({ type: "Polygon", coordinates: t }, e, r) } function o(t, e, r) { if (void 0 === r && (r = {}), t.length < 2) throw new Error("coordinates must be an array of two or more positions"); return n({ type: "LineString", coordinates: t }, e, r) } function s(t, e) { void 0 === e && (e = {}); var n = { type: "FeatureCollection" }; return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n } function a(t, e, r) { return void 0 === r && (r = {}), n({ type: "MultiLineString", coordinates: t }, e, r) } function u(t, e, r) { return void 0 === r && (r = {}), n({ type: "MultiPoint", coordinates: t }, e, r) } function l(t, e, r) { return void 0 === r && (r = {}), n({ type: "MultiPolygon", coordinates: t }, e, r) } function c(t, n) { void 0 === n && (n = "kilometers"); var r = e.factors[n]; if (!r) throw new Error(n + " units is invalid"); return t * r } function h(t, n) { void 0 === n && (n = "kilometers"); var r = e.factors[n]; if (!r) throw new Error(n + " units is invalid"); return t / r } function p(t) { return 180 * (t % (2 * Math.PI)) / Math.PI } function f(t) { return !isNaN(t) && null !== t && !Array.isArray(t) } Object.defineProperty(e, "__esModule", { value: !0 }), e.earthRadius = 6371008.8, e.factors = { centimeters: 100 * e.earthRadius, centimetres: 100 * e.earthRadius, degrees: e.earthRadius / 111325, feet: 3.28084 * e.earthRadius, inches: 39.37 * e.earthRadius, kilometers: e.earthRadius / 1e3, kilometres: e.earthRadius / 1e3, meters: e.earthRadius, metres: e.earthRadius, miles: e.earthRadius / 1609.344, millimeters: 1e3 * e.earthRadius, millimetres: 1e3 * e.earthRadius, nauticalmiles: e.earthRadius / 1852, radians: 1, yards: e.earthRadius / 1.0936 }, e.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / e.earthRadius, yards: 1 / 1.0936 }, e.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, e.feature = n, e.geometry = function (t, e, n) { switch (t) { case "Point": return r(e).geometry; case "LineString": return o(e).geometry; case "Polygon": return i(e).geometry; case "MultiPoint": return u(e).geometry; case "MultiLineString": return a(e).geometry; case "MultiPolygon": return l(e).geometry; default: throw new Error(t + " is invalid") } }, e.point = r, e.points = function (t, e, n) { return void 0 === n && (n = {}), s(t.map((function (t) { return r(t, e) })), n) }, e.polygon = i, e.polygons = function (t, e, n) { return void 0 === n && (n = {}), s(t.map((function (t) { return i(t, e) })), n) }, e.lineString = o, e.lineStrings = function (t, e, n) { return void 0 === n && (n = {}), s(t.map((function (t) { return o(t, e) })), n) }, e.featureCollection = s, e.multiLineString = a, e.multiPoint = u, e.multiPolygon = l, e.geometryCollection = function (t, e, r) { return void 0 === r && (r = {}), n({ type: "GeometryCollection", geometries: t }, e, r) }, e.round = function (t, e) { if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error("precision must be a positive number"); var n = Math.pow(10, e || 0); return Math.round(t * n) / n }, e.radiansToLength = c, e.lengthToRadians = h, e.lengthToDegrees = function (t, e) { return p(h(t, e)) }, e.bearingToAzimuth = function (t) { var e = t % 360; return e < 0 && (e += 360), e }, e.radiansToDegrees = p, e.degreesToRadians = function (t) { return t % 360 * Math.PI / 180 }, e.convertLength = function (t, e, n) { if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("length must be a positive number"); return c(h(t, e), n) }, e.convertArea = function (t, n, r) { if (void 0 === n && (n = "meters"), void 0 === r && (r = "kilometers"), !(t >= 0)) throw new Error("area must be a positive number"); var i = e.areaFactors[n]; if (!i) throw new Error("invalid original units"); var o = e.areaFactors[r]; if (!o) throw new Error("invalid final units"); return t / i * o }, e.isNumber = f, e.isObject = function (t) { return !!t && t.constructor === Object }, e.validateBBox = function (t) { if (!t) throw new Error("bbox is required"); if (!Array.isArray(t)) throw new Error("bbox must be an Array"); if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); t.forEach((function (t) { if (!f(t)) throw new Error("bbox must only contain numbers") })) }, e.validateId = function (t) { if (!t) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof t)) throw new Error("id must be a number or a string") } })); function Kn(t, e, n) { if (null !== t) for (var r, i, o, s, a, u, l, c, h = 0, p = 0, f = t.type, g = "FeatureCollection" === f, d = "Feature" === f, y = g ? t.features.length : 1, v = 0; v < y; v++) { a = (c = !!(l = g ? t.features[v].geometry : d ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var _ = 0; _ < a; _++) { var m = 0, x = 0; if (null !== (s = c ? l.geometries[_] : l)) { u = s.coordinates; var E = s.type; switch (h = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) { case null: break; case "Point": if (!1 === e(u, p, v, m, x)) return !1; p++, m++; break; case "LineString": case "MultiPoint": for (r = 0; r < u.length; r++) { if (!1 === e(u[r], p, v, m, x)) return !1; p++, "MultiPoint" === E && m++ } "LineString" === E && m++; break; case "Polygon": case "MultiLineString": for (r = 0; r < u.length; r++) { for (i = 0; i < u[r].length - h; i++) { if (!1 === e(u[r][i], p, v, m, x)) return !1; p++ } "MultiLineString" === E && m++, "Polygon" === E && x++ } "Polygon" === E && m++; break; case "MultiPolygon": for (r = 0; r < u.length; r++) { for (x = 0, i = 0; i < u[r].length; i++) { for (o = 0; o < u[r][i].length - h; o++) { if (!1 === e(u[r][i][o], p, v, m, x)) return !1; p++ } x++ } m++ } break; case "GeometryCollection": for (r = 0; r < s.geometries.length; r++)if (!1 === Kn(s.geometries[r], e, n)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function Qn(t, e) { var n; switch (t.type) { case "FeatureCollection": for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++); break; case "Feature": e(t.properties, 0) } } function $n(t, e) { if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++); } function tr(t, e) { var n, r, i, o, s, a, u, l, c, h, p = 0, f = "FeatureCollection" === t.type, g = "Feature" === t.type, d = f ? t.features.length : 1; for (n = 0; n < d; n++) { for (a = f ? t.features[n].geometry : g ? t.geometry : t, l = f ? t.features[n].properties : g ? t.properties : {}, c = f ? t.features[n].bbox : g ? t.bbox : void 0, h = f ? t.features[n].id : g ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++)if (null !== (o = u ? a.geometries[i] : a)) switch (o.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === e(o, p, l, c, h)) return !1; break; case "GeometryCollection": for (r = 0; r < o.geometries.length; r++)if (!1 === e(o.geometries[r], p, l, c, h)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === e(null, p, l, c, h)) return !1; p++ } } function er(t, e) { tr(t, (function (t, n, r, i, o) { var s, a = null === t ? null : t.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 !== e(Zn.feature(t, r, { bbox: i, id: o }), n, 0) && void 0 }switch (a) { case "MultiPoint": s = "Point"; break; case "MultiLineString": s = "LineString"; break; case "MultiPolygon": s = "Polygon" }for (var u = 0; u < t.coordinates.length; u++) { var l = { type: s, coordinates: t.coordinates[u] }; if (!1 === e(Zn.feature(l, r), n, u)) return !1 } })) } function nr(t, e) { er(t, (function (t, n, r) { var i = 0; if (t.geometry) { var o = t.geometry.type; if ("Point" !== o && "MultiPoint" !== o) { var s, a = 0, u = 0, l = 0; return !1 !== Kn(t, (function (o, c, h, p, f) { if (void 0 === s || n > a || p > u || f > l) return s = o, a = n, u = p, l = f, void (i = 0); var g = Zn.lineString([s, o], t.properties); if (!1 === e(g, n, r, f, i)) return !1; i++, s = o })) && void 0 } } })) } function rr(t, e) { if (!t) throw new Error("geojson is required"); er(t, (function (t, n, r) { if (null !== t.geometry) { var i = t.geometry.type, o = t.geometry.coordinates; switch (i) { case "LineString": if (!1 === e(t, n, r, 0, 0)) return !1; break; case "Polygon": for (var s = 0; s < o.length; s++)if (!1 === e(Zn.lineString(o[s], t.properties), n, r, s)) return !1 } } })) } var ir = Kn, or = function (t, e, n, r) { var i = n; return Kn(t, (function (t, r, o, s, a) { i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a) }), r), i }, sr = Qn, ar = function (t, e, n) { var r = n; return Qn(t, (function (t, i) { r = 0 === i && void 0 === n ? t : e(r, t, i) })), r }, ur = $n, lr = function (t, e, n) { var r = n; return $n(t, (function (t, i) { r = 0 === i && void 0 === n ? t : e(r, t, i) })), r }, cr = function (t) { var e = []; return Kn(t, (function (t) { e.push(t) })), e }, hr = tr, pr = function (t, e, n) { var r = n; return tr(t, (function (t, i, o, s, a) { r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a) })), r }, fr = er, gr = function (t, e, n) { var r = n; return er(t, (function (t, i, o) { r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o) })), r }, dr = nr, yr = function (t, e, n) { var r = n, i = !1; return nr(t, (function (t, o, s, a, u) { r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0 })), r }, vr = rr, _r = function (t, e, n) { var r = n; return rr(t, (function (t, i, o, s) { r = 0 === i && void 0 === n ? t : e(r, t, i, o, s) })), r }, mr = function (t, e) { if (e = e || {}, !Zn.isObject(e)) throw new Error("options is invalid"); var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.segmentIndex || 0, a = e.properties; switch (t.type) { case "FeatureCollection": r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry; break; case "Feature": a = a || t.properties, n = t.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": n = t; break; default: throw new Error("geojson is invalid") }if (null === n) return null; var u = n.coordinates; switch (n.type) { case "Point": case "MultiPoint": return null; case "LineString": return s < 0 && (s = u.length + s - 1), Zn.lineString([u[s], u[s + 1]], a, e); case "Polygon": return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), Zn.lineString([u[o][s], u[o][s + 1]], a, e); case "MultiLineString": return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), Zn.lineString([u[i][s], u[i][s + 1]], a, e); case "MultiPolygon": return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), Zn.lineString([u[i][o][s], u[i][o][s + 1]], a, e) }throw new Error("geojson is invalid") }, xr = function (t, e) { if (e = e || {}, !Zn.isObject(e)) throw new Error("options is invalid"); var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.coordIndex || 0, a = e.properties; switch (t.type) { case "FeatureCollection": r < 0 && (r = t.features.length + r), a = a || t.features[r].properties, n = t.features[r].geometry; break; case "Feature": a = a || t.properties, n = t.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": n = t; break; default: throw new Error("geojson is invalid") }if (null === n) return null; var u = n.coordinates; switch (n.type) { case "Point": return Zn.point(u, a, e); case "MultiPoint": return i < 0 && (i = u.length + i), Zn.point(u[i], a, e); case "LineString": return s < 0 && (s = u.length + s), Zn.point(u[s], a, e); case "Polygon": return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s), Zn.point(u[o][s], a, e); case "MultiLineString": return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), Zn.point(u[i][s], a, e); case "MultiPolygon": return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s), Zn.point(u[i][o][s], a, e) }throw new Error("geojson is invalid") }, Er = Object.defineProperty({ coordEach: ir, coordReduce: or, propEach: sr, propReduce: ar, featureEach: ur, featureReduce: lr, coordAll: cr, geomEach: hr, geomReduce: pr, flattenEach: fr, flattenReduce: gr, segmentEach: dr, segmentReduce: yr, lineEach: vr, lineReduce: _r, findSegment: mr, findPoint: xr }, "__esModule", { value: !0 }); function br(t) { var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return Er.coordEach(t, (function (t) { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]) })), e } br.default = br; var wr = br, Ir = Object.defineProperty({ default: wr }, "__esModule", { value: !0 }).default, Nr = Er.featureEach, Sr = (Er.coordEach, Zn.polygon, Zn.featureCollection); function Cr(t) { var e = Nt(t); return e.insert = function (t) { if ("Feature" !== t.type) throw new Error("invalid feature"); return t.bbox = t.bbox ? t.bbox : Ir(t), Nt.prototype.insert.call(this, t) }, e.load = function (t) { var e = []; return Array.isArray(t) ? t.forEach((function (t) { if ("Feature" !== t.type) throw new Error("invalid features"); t.bbox = t.bbox ? t.bbox : Ir(t), e.push(t) })) : Nr(t, (function (t) { if ("Feature" !== t.type) throw new Error("invalid features"); t.bbox = t.bbox ? t.bbox : Ir(t), e.push(t) })), Nt.prototype.load.call(this, e) }, e.remove = function (t, e) { if ("Feature" !== t.type) throw new Error("invalid feature"); return t.bbox = t.bbox ? t.bbox : Ir(t), Nt.prototype.remove.call(this, t, e) }, e.clear = function () { return Nt.prototype.clear.call(this) }, e.search = function (t) { var e = Nt.prototype.search.call(this, this.toBBox(t)); return Sr(e) }, e.collides = function (t) { return Nt.prototype.collides.call(this, this.toBBox(t)) }, e.all = function () { var t = Nt.prototype.all.call(this); return Sr(t) }, e.toJSON = function () { return Nt.prototype.toJSON.call(this) }, e.fromJSON = function (t) { return Nt.prototype.fromJSON.call(this, t) }, e.toBBox = function (t) { var e; if (t.bbox) e = t.bbox; else if (Array.isArray(t) && 4 === t.length) e = t; else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]]; else if ("Feature" === t.type) e = Ir(t); else { if ("FeatureCollection" !== t.type) throw new Error("invalid geojson"); e = Ir(t) } return { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] } }, e } var Pr = Cr, Lr = Cr; function Mr(t, e) { var n = {}, r = []; if ("LineString" === t.type && (t = o(t)), "LineString" === e.type && (e = o(e)), "Feature" === t.type && "Feature" === e.type && null !== t.geometry && null !== e.geometry && "LineString" === t.geometry.type && "LineString" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) { var i = Or(t, e); return i && r.push(i), f(r) } var s = Pr(); return s.load(Jn(e)), X(Jn(t), (function (t) { X(s.search(t), (function (e) { var i = Or(t, e); if (i) { var o = T(i).join(","); n[o] || (n[o] = !0, r.push(i)) } })) })), f(r) } function Or(t, e) { var n = T(t), r = T(e); if (2 !== n.length) throw new Error("<intersects> line1 must only contain 2 coordinates"); if (2 !== r.length) throw new Error("<intersects> line2 must only contain 2 coordinates"); var i = n[0][0], o = n[0][1], s = n[1][0], u = n[1][1], l = r[0][0], c = r[0][1], h = r[1][0], p = r[1][1], f = (p - c) * (s - i) - (h - l) * (u - o), g = (h - l) * (o - c) - (p - c) * (i - l), d = (s - i) * (o - c) - (u - o) * (i - l); if (0 === f) return null; var y = g / f, v = d / f; return y >= 0 && y <= 1 && v >= 0 && v <= 1 ? a([i + y * (s - i), o + y * (u - o)]) : null } function Rr(t, e, n) { void 0 === n && (n = {}); var r = a([1 / 0, 1 / 0], { dist: 1 / 0 }), i = 0; return Z(t, (function (t) { for (var o = T(t), s = 0; s < o.length - 1; s++) { var u = a(o[s]); u.properties.dist = me(e, u, n); var l = a(o[s + 1]); l.properties.dist = me(e, l, n); var c = me(u, l, n), p = Math.max(u.properties.dist, l.properties.dist), f = _n(u, l), g = yn(e, p, f + 90, n), d = yn(e, p, f - 90, n), y = Mr(h([g.geometry.coordinates, d.geometry.coordinates]), h([u.geometry.coordinates, l.geometry.coordinates])), v = null; y.features.length > 0 && ((v = y.features[0]).properties.dist = me(e, v, n), v.properties.location = i + me(u, v, n)), u.properties.dist < r.properties.dist && ((r = u).properties.index = s, r.properties.location = i), l.properties.dist < r.properties.dist && ((r = l).properties.index = s + 1, r.properties.location = i + c), v && v.properties.dist < r.properties.dist && ((r = v).properties.index = s), i += c } })), r } function Tr(t, n, r) { void 0 === r && (r = {}); var i = R(t), o = R(n); return o[0] += o[0] - i[0] > 180 ? -360 : i[0] - o[0] > 180 ? 360 : 0, N(function (t, n, r) { var i = r = void 0 === r ? e : Number(r), o = t[1] * Math.PI / 180, s = n[1] * Math.PI / 180, a = s - o, u = Math.abs(n[0] - t[0]) * Math.PI / 180; u > Math.PI && (u -= 2 * Math.PI); var l = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)), c = Math.abs(l) > 1e-11 ? a / l : Math.cos(o); return Math.sqrt(a * a + c * c * u * u) * i }(i, o), "meters", r.units) } function Ar(t, e, n) { if (void 0 === n && (n = {}), n.method || (n.method = "geodesic"), n.units || (n.units = "kilometers"), !t) throw new Error("pt is required"); if (Array.isArray(t) ? t = a(t) : "Point" === t.type ? t = o(t) : F(t, "Point", "point"), !e) throw new Error("line is required"); Array.isArray(e) ? e = h(e) : "LineString" === e.type ? e = o(e) : F(e, "LineString", "line"); var r = 1 / 0, i = t.geometry.coordinates; return Q(e, (function (t) { var e = t.geometry.coordinates[0], o = t.geometry.coordinates[1], s = function (t, e, n, r) { var i = [n[0] - e[0], n[1] - e[1]], o = Dr([t[0] - e[0], t[1] - e[1]], i); if (o <= 0) return Fr(t, e, { method: r.method, units: "degrees" }); var s = Dr(i, i); if (s <= o) return Fr(t, n, { method: r.method, units: "degrees" }); var a = o / s, u = [e[0] + a * i[0], e[1] + a * i[1]]; return Fr(t, u, { method: r.method, units: "degrees" }) }(i, e, o, n); s < r && (r = s) })), N(r, "degrees", n.units) } function Dr(t, e) { return t[0] * e[0] + t[1] * e[1] } function Fr(t, e, n) { return "planar" === n.method ? Tr(t, e, n) : me(t, e, n) } function kr(t, e, n, r, i, o, s, a) { var u, l, c, h, p = { x: null, y: null, onLine1: !1, onLine2: !1 }; return 0 === (u = (a - o) * (n - t) - (s - i) * (r - e)) ? null !== p.x && null !== p.y && p : (h = (n - t) * (l = e - o) - (r - e) * (c = t - i), l = ((s - i) * l - (a - o) * c) / u, c = h / u, p.x = t + l * (n - t), p.y = e + l * (r - e), l >= 0 && l <= 1 && (p.onLine1 = !0), c >= 0 && c <= 1 && (p.onLine2 = !0), !(!p.onLine1 || !p.onLine2) && [p.x, p.y]) } function Gr(t) { for (var e = function (t) { if ("FeatureCollection" !== t.type) return "Feature" !== t.type ? f([o(t)]) : f([t]); return t }(t), n = mn(e), r = !1, i = 0; !r && i < e.features.length;) { var s, u = e.features[i].geometry, l = !1; if ("Point" === u.type) n.geometry.coordinates[0] === u.coordinates[0] && n.geometry.coordinates[1] === u.coordinates[1] && (r = !0); else if ("MultiPoint" === u.type) { var c = !1; for (s = 0; !c && s < u.coordinates.length;)n.geometry.coordinates[0] === u.coordinates[s][0] && n.geometry.coordinates[1] === u.coordinates[s][1] && (r = !0, c = !0), s++ } else if ("LineString" === u.type) for (s = 0; !l && s < u.coordinates.length - 1;)qr(n.geometry.coordinates[0], n.geometry.coordinates[1], u.coordinates[s][0], u.coordinates[s][1], u.coordinates[s + 1][0], u.coordinates[s + 1][1]) && (l = !0, r = !0), s++; else if ("MultiLineString" === u.type) for (var h = 0; h < u.coordinates.length;) { l = !1, s = 0; for (var p = u.coordinates[h]; !l && s < p.length - 1;)qr(n.geometry.coordinates[0], n.geometry.coordinates[1], p[s][0], p[s][1], p[s + 1][0], p[s + 1][1]) && (l = !0, r = !0), s++; h++ } else "Polygon" !== u.type && "MultiPolygon" !== u.type || ye(n, u) && (r = !0); i++ } if (r) return n; var g = f([]); for (i = 0; i < e.features.length; i++)g.features = g.features.concat(En(e.features[i]).features); return a(Wn(n, g).geometry.coordinates) } function qr(t, e, n, r, i, o) { return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e)) } Pr.default = Lr; var Br = 6378137; function zr(t) { return J(t, (function (t, e) { return t + function (t) { var e, n = 0; switch (t.type) { case "Polygon": return jr(t.coordinates); case "MultiPolygon": for (e = 0; e < t.coordinates.length; e++)n += jr(t.coordinates[e]); return n; case "Point": case "MultiPoint": case "LineString": case "MultiLineString": return 0 }return 0 }(e) }), 0) } function jr(t) { var e = 0; if (t && t.length > 0) { e += Math.abs(Ur(t[0])); for (var n = 1; n < t.length; n++)e -= Math.abs(Ur(t[n])) } return e } function Ur(t) { var e, n, r, i, o, s, a = 0, u = t.length; if (u > 2) { for (s = 0; s < u; s++)s === u - 2 ? (r = u - 2, i = u - 1, o = 0) : s === u - 1 ? (r = u - 1, i = 0, o = 1) : (r = s, i = s + 1, o = s + 2), e = t[r], n = t[i], a += (Vr(t[o][0]) - Vr(e[0])) * Math.sin(Vr(n[1])); a = a * Br * Br / 2 } return a } function Vr(t) { return t * Math.PI / 180 } function Xr(t, e) { return void 0 === e && (e = {}), $(t, (function (t, n) { var r = n.geometry.coordinates; return t + me(r[0], r[1], e) }), 0) } function Yr(t, e, n, r) { if (!P(r = r || {})) throw new Error("options is invalid"); var i, o = []; if ("Feature" === t.type) i = t.geometry.coordinates; else { if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry"); i = t.coordinates } for (var s, a, u, l = i.length, c = 0, p = 0; p < i.length && !(e >= c && p === i.length - 1); p++) { if (c > e && 0 === o.length) { if (!(s = e - c)) return o.push(i[p]), h(o); a = _n(i[p], i[p - 1]) - 180, u = yn(i[p], s, a, r), o.push(u.geometry.coordinates) } if (c >= n) return (s = n - c) ? (a = _n(i[p], i[p - 1]) - 180, u = yn(i[p], s, a, r), o.push(u.geometry.coordinates), h(o)) : (o.push(i[p]), h(o)); if (c >= e && o.push(i[p]), p === i.length - 1) return h(o); c += me(i[p], i[p + 1], r) } if (c < e && i.length === l) throw new Error("Start position is beyond line"); return h(i[i.length - 1]) } function Hr(t, e, n) { void 0 === n && (n = {}); for (var r = R(t), i = T(e), o = 0; o < i.length - 1; o++) { var s = !1; if (n.ignoreEndVertices && (0 === o && (s = "start"), o === i.length - 2 && (s = "end"), 0 === o && o + 1 === i.length - 1 && (s = "both")), Wr(i[o], i[o + 1], r, s)) return !0 } return !1 } function Wr(t, e, n, r) { var i = n[0], o = n[1], s = t[0], a = t[1], u = e[0], l = e[1], c = u - s, h = l - a; return 0 == (n[0] - s) * h - (n[1] - a) * c && (r ? "start" === r ? Math.abs(c) >= Math.abs(h) ? c > 0 ? s < i && i <= u : u <= i && i < s : h > 0 ? a < o && o <= l : l <= o && o < a : "end" === r ? Math.abs(c) >= Math.abs(h) ? c > 0 ? s <= i && i < u : u < i && i <= s : h > 0 ? a <= o && o < l : l < o && o <= a : "both" === r && (Math.abs(c) >= Math.abs(h) ? c > 0 ? s < i && i < u : u < i && i < s : h > 0 ? a < o && o < l : l < o && o < a) : Math.abs(c) >= Math.abs(h) ? c > 0 ? s <= i && i <= u : u <= i && i <= s : h > 0 ? a <= o && o <= l : l <= o && o <= a) } function Jr(t, e) { var n = G(t), r = G(e), i = n.type, o = r.type; switch (i) { case "Point": switch (o) { case "MultiPoint": return function (t, e) { var n, r = !1; for (n = 0; n < e.coordinates.length; n++)if (Kr(e.coordinates[n], t.coordinates)) { r = !0; break } return r }(n, r); case "LineString": return Hr(n, r, { ignoreEndVertices: !0 }); case "Polygon": case "MultiPolygon": return ye(n, r, { ignoreBoundary: !0 }); default: throw new Error("feature2 " + o + " geometry not supported") }case "MultiPoint": switch (o) { case "MultiPoint": return function (t, e) { for (var n = 0; n < t.coordinates.length; n++) { for (var r = !1, i = 0; i < e.coordinates.length; i++)Kr(t.coordinates[n], e.coordinates[i]) && (r = !0); if (!r) return !1 } return !0 }(n, r); case "LineString": return function (t, e) { for (var n = !1, r = 0; r < t.coordinates.length; r++) { if (!Hr(t.coordinates[r], e)) return !1; n || (n = Hr(t.coordinates[r], e, { ignoreEndVertices: !0 })) } return n }(n, r); case "Polygon": case "MultiPolygon": return function (t, e) { for (var n = !0, r = 0; r < t.coordinates.length; r++) { var i = ye(t.coordinates[1], e); if (!i) { n = !1; break } i = ye(t.coordinates[1], e, { ignoreBoundary: !0 }) } return n && i }(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "LineString": switch (o) { case "LineString": return function (t, e) { for (var n = 0; n < t.coordinates.length; n++)if (!Hr(t.coordinates[n], e)) return !1; return !0 }(n, r); case "Polygon": case "MultiPolygon": return function (t, e) { var n = ot(e), r = ot(t); if (!Zr(n, r)) return !1; for (var i = !1, o = 0; o < t.coordinates.length - 1; o++) { if (!ye(t.coordinates[o], e)) return !1; if (i || (i = ye(t.coordinates[o], e, { ignoreBoundary: !0 })), !i) i = ye(Qr(t.coordinates[o], t.coordinates[o + 1]), e, { ignoreBoundary: !0 }) } return i }(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "Polygon": switch (o) { case "Polygon": case "MultiPolygon": return function (t, e) { var n = ot(t); if (!Zr(ot(e), n)) return !1; for (var r = 0; r < t.coordinates[0].length; r++)if (!ye(t.coordinates[0][r], e)) return !1; return !0 }(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }default: throw new Error("feature1 " + i + " geometry not supported") } } function Zr(t, e) { return !(t[0] > e[0]) && (!(t[2] < e[2]) && (!(t[1] > e[1]) && !(t[3] < e[3]))) } function Kr(t, e) { return t[0] === e[0] && t[1] === e[1] } function Qr(t, e) { return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2] } function $r(t, e, n) { void 0 === n && (n = {}), n.mask && !n.units && (n.units = "kilometers"); for (var r = [], i = t[0], o = t[1], s = t[2], u = t[3], l = e / me([i, o], [s, o], n) * (s - i), c = e / me([i, o], [i, u], n) * (u - o), h = s - i, p = u - o, g = Math.floor(h / l), d = (p - Math.floor(p / c) * c) / 2, y = i + (h - g * l) / 2; y <= s;) { for (var v = o + d; v <= u;) { var _ = a([y, v], n.properties); n.mask ? Jr(_, n.mask) && r.push(_) : r.push(_), v += c } y += l } return f(r) } function ti(t, e) { void 0 === e && (e = {}); var n = e.precision, r = e.coordinates, i = e.mutate; if (n = null == n || isNaN(n) ? 6 : n, r = null == r || isNaN(r) ? 3 : r, !t) throw new Error("<geojson> is required"); if ("number" != typeof n) throw new Error("<precision> must be a number"); if ("number" != typeof r) throw new Error("<coordinates> must be a number"); !1 !== i && void 0 !== i || (t = JSON.parse(JSON.stringify(t))); var o = Math.pow(10, n); return z(t, (function (t) { !function (t, e, n) { t.length > n && t.splice(n, t.length); for (var r = 0; r < t.length; r++)t[r] = Math.round(t[r] * e) / e }(t, o, r) })), t } function ei(t, e, n) { if ("Polygon" !== t.geometry.type) throw new Error("The input feature must be a Polygon"); void 0 === n && (n = 1); var r = t.geometry.coordinates, i = [], o = {}; if (n) { for (var s = [], a = 0; a < r.length; a++)for (var u = 0; u < r[a].length - 1; u++)s.push(d(a, u)); var l = Nt(); l.load(s) } for (var c = 0; c < r.length; c++)for (var h = 0; h < r[c].length - 1; h++) { if (n) l.search(d(c, h)).forEach((function (t) { var e = t.ring, n = t.edge; g(c, h, e, n) })); else for (var p = 0; p < r.length; p++)for (var f = 0; f < r[p].length - 1; f++)g(c, h, p, f) } return e || (i = { type: "Feature", geometry: { type: "MultiPoint", coordinates: i } }), i; function g(t, n, s, a) { var u, l, c = r[t][n], h = r[t][n + 1], p = r[s][a], f = r[s][a + 1], g = function (t, e, n, r) { if (ni(t, n) || ni(t, r) || ni(e, n) || ni(r, n)) return null; var i = t[0], o = t[1], s = e[0], a = e[1], u = n[0], l = n[1], c = r[0], h = r[1], p = (i - s) * (l - h) - (o - a) * (u - c); return 0 === p ? null : [((i * a - o * s) * (u - c) - (i - s) * (u * h - l * c)) / p, ((i * a - o * s) * (l - h) - (o - a) * (u * h - l * c)) / p] }(c, h, p, f); if (null !== g && (u = h[0] !== c[0] ? (g[0] - c[0]) / (h[0] - c[0]) : (g[1] - c[1]) / (h[1] - c[1]), l = f[0] !== p[0] ? (g[0] - p[0]) / (f[0] - p[0]) : (g[1] - p[1]) / (f[1] - p[1]), !(u >= 1 || u <= 0 || l >= 1 || l <= 0))) { var d = g, y = !o[d]; y && (o[d] = !0), e ? i.push(e(g, t, n, c, h, u, s, a, p, f, l, y)) : i.push(g) } } function d(t, e) { var n, i, o, s, a = r[t][e], u = r[t][e + 1]; return a[0] < u[0] ? (n = a[0], i = u[0]) : (n = u[0], i = a[0]), a[1] < u[1] ? (o = a[1], s = u[1]) : (o = u[1], s = a[1]), { minX: n, minY: o, maxX: i, maxY: s, ring: t, edge: e } } } function ni(t, e) { if (!t || !e) return !1; if (t.length !== e.length) return !1; for (var n = 0, r = t.length; n < r; n++)if (t[n] instanceof Array && e[n] instanceof Array) { if (!ni(t[n], e[n])) return !1 } else if (t[n] !== e[n]) return !1; return !0 } var ri = function (t, e, n, r, i) { this.coord = t, this.param = e, this.ringAndEdgeIn = n, this.ringAndEdgeOut = r, this.nxtIsectAlongEdgeIn = i }, ii = function (t, e, n, r, i, o, s) { this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = n, this.nxtIsectAlongRingAndEdge1 = r, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = o, this.ringAndEdge2Walkable = s }; function oi(t, e) { if (void 0 === e && (e = !0), 3 != t.length) throw new Error("This function requires an array of three points [x,y]"); return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e } function si(t) { for (var e = 0, n = 0; n < t.length - 1; n++)t[n][0] < t[e][0] && (e = n); if (oi([t[ui(e - 1, t.length - 1)], t[e], t[ui(e + 1, t.length - 1)]], !0)) var r = 1; else r = -1; return r } function ai(t, e) { if (!t || !e) return !1; if (t.length != e.length) return !1; for (var n = 0, r = t.length; n < r; n++)if (t[n] instanceof Array && e[n] instanceof Array) { if (!ai(t[n], e[n])) return !1 } else if (t[n] != e[n]) return !1; return !0 } function ui(t, e) { return (t % e + e) % e } var li = Math.PI / 180, ci = 180 / Math.PI, hi = function (t, e) { this.lon = t, this.lat = e, this.x = li * t, this.y = li * e }; hi.prototype.view = function () { return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4) }, hi.prototype.antipode = function () { var t = -1 * this.lat, e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon); return new hi(e, t) }; var pi = function () { this.coords = [], this.length = 0 }; pi.prototype.move_to = function (t) { this.length++, this.coords.push(t) }; var fi = function (t) { this.properties = t || {}, this.geometries = [] }; fi.prototype.json = function () { if (this.geometries.length <= 0) return { geometry: { type: "LineString", coordinates: null }, type: "Feature", properties: this.properties }; if (1 === this.geometries.length) return { geometry: { type: "LineString", coordinates: this.geometries[0].coords }, type: "Feature", properties: this.properties }; for (var t = [], e = 0; e < this.geometries.length; e++)t.push(this.geometries[e].coords); return { geometry: { type: "MultiLineString", coordinates: t }, type: "Feature", properties: this.properties } }, fi.prototype.wkt = function () { for (var t = "", e = "LINESTRING(", n = function (t) { e += t[0] + " " + t[1] + "," }, r = 0; r < this.geometries.length; r++) { if (0 === this.geometries[r].coords.length) return "LINESTRING(empty)"; this.geometries[r].coords.forEach(n), t += e.substring(0, e.length - 1) + ")" } return t }; var gi = function (t, e, n) { if (!t || void 0 === t.x || void 0 === t.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties"); if (!e || void 0 === e.x || void 0 === e.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties"); this.start = new hi(t.x, t.y), this.end = new hi(e.x, e.y), this.properties = n || {}; var r = this.start.x - this.end.x, i = this.start.y - this.end.y, o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2); if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI) throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"); if (isNaN(this.g)) throw new Error("could not calculate great circle between " + t + " and " + e) }; function di(t, e) { var n = [], r = Pr(); return Z(e, (function (e) { if (n.forEach((function (t, e) { t.id = e })), n.length) { var i = r.search(e); if (i.features.length) { var o = vi(e, i); n = n.filter((function (t) { return t.id !== o.id })), r.remove(o), X(yi(o, e), (function (t) { n.push(t), r.insert(t) })) } } else (n = yi(t, e).features).forEach((function (t) { t.bbox || (t.bbox = dn(ot(t))) })), r.load(f(n)) })), f(n) } function yi(t, e) { var n = [], r = T(t)[0], i = T(t)[t.geometry.coordinates.length - 1]; if (_i(r, R(e)) || _i(i, R(e))) return f([t]); var o = Pr(), s = Jn(t); o.load(s); var a = o.search(e); if (!a.features.length) return f([t]); var u = vi(e, a), l = Y(s, (function (t, r, i) { var o = T(r)[1], s = R(e); return i === u.id ? (t.push(s), n.push(h(t)), _i(s, o) ? [s] : [s, o]) : (t.push(o), t) }), [r]); return l.length > 1 && n.push(h(l)), f(n) } function vi(t, e) { if (!e.features.length) throw new Error("lines must contain features"); if (1 === e.features.length) return e.features[0]; var n, r = 1 / 0; return X(e, (function (e) { var i = Rr(e, t).properties.dist; i < r && (n = e, r = i) })), n } function _i(t, e) { return t[0] === e[0] && t[1] === e[1] } function mi(t, e, n, r, i) { void 0 === i && (i = {}); var o = i.steps || 64, s = xi(n), a = xi(r), u = Array.isArray(t) || "Feature" !== t.type ? {} : t.properties; if (s === a) return h(vn(t, e, i).geometry.coordinates[0], u); for (var l = s, c = s < a ? a : a + 360, p = l, f = [], g = 0; p < c;)f.push(yn(t, e, p, i).geometry.coordinates), p = l + 360 * ++g / o; return p > c && f.push(yn(t, e, c, i).geometry.coordinates), h(f, u) } function xi(t) { var e = t % 360; return e < 0 && (e += 360), e } function Ei(t, e) { void 0 === e && (e = {}); var n = G(t); switch (e.properties || "Feature" !== t.type || (e.properties = t.properties), n.type) { case "Polygon": return bi(n, e); case "MultiPolygon": return function (t, e) { void 0 === e && (e = {}); var n = G(t).coordinates, r = e.properties ? e.properties : "Feature" === t.type ? t.properties : {}, i = []; return n.forEach((function (t) { i.push(wi(t, r)) })), f(i) }(n, e); default: throw new Error("invalid poly") } } function bi(t, e) { return void 0 === e && (e = {}), wi(G(t).coordinates, e.properties ? e.properties : "Feature" === t.type ? t.properties : {}) } function wi(t, e) { return t.length > 1 ? g(t, e) : h(t[0], e) } function Ii(t, e) { void 0 === e && (e = {}); var n = e.properties, r = e.autoComplete, i = e.orderCoords, o = e.mutate; switch (r = void 0 === r || r, i = void 0 === i || i, (o = void 0 !== o && o) || (t = Ie(t)), t.type) { case "FeatureCollection": var s = []; return t.features.forEach((function (t) { s.push(T(Ni(t, {}, r, i))) })), y(s, n); default: return Ni(t, n, r, i) } } function Ni(t, e, n, r) { e = e || ("Feature" === t.type ? t.properties : {}); var i = G(t), o = i.coordinates, s = i.type; if (!o.length) throw new Error("line must contain coordinates"); switch (s) { case "LineString": return n && (o = Si(o)), l([o], e); case "MultiLineString": var a = [], u = 0; return o.forEach((function (t) { if (n && (t = Si(t)), r) { var e = function (t) { var e = t[0], n = t[1], r = t[2], i = t[3]; return Math.abs(e - r) * Math.abs(n - i) }(ot(h(t))); e > u ? (a.unshift(t), u = e) : a.push(t) } else a.push(t) })), l(a, e); default: throw new Error("geometry type " + s + " is not supported") } } function Si(t) { var e = t[0], n = e[0], r = e[1], i = t[t.length - 1], o = i[0], s = i[1]; return n === o && r === s || t.push(e), t } function Ci(t, e) { var n, r, i, o, s, a, u; for (r = 1; r <= 8; r *= 2) { for (n = [], o = !(Li(i = t[t.length - 1], e) & r), s = 0; s < t.length; s++)(u = !(Li(a = t[s], e) & r)) !== o && n.push(Pi(i, a, r, e)), u && n.push(a), i = a, o = u; if (!(t = n).length) break } return n } function Pi(t, e, n, r) { return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null } function Li(t, e) { var n = 0; return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n } function Mi(t, e) { for (var n = [], r = 0, i = t; r < i.length; r++) { var o = Ci(i[r], e); o.length > 0 && (o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1] || o.push(o[0]), o.length >= 4 && n.push(o)) } return n } gi.prototype.interpolate = function (t) { var e = Math.sin((1 - t) * this.g) / Math.sin(this.g), n = Math.sin(t * this.g) / Math.sin(this.g), r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x), i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x), o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y), s = ci * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2))); return [ci * Math.atan2(i, r), s] }, gi.prototype.Arc = function (t, e) { var n = []; if (!t || t <= 2) n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]); else for (var r = 1 / (t - 1), i = 0; i < t; ++i) { var o = r * i, s = this.interpolate(o); n.push(s) } for (var a = !1, u = 0, l = e && e.offset ? e.offset : 10, c = 180 - l, h = -180 + l, p = 360 - l, f = 1; f < n.length; ++f) { var g = n[f - 1][0], d = n[f][0], y = Math.abs(d - g); y > p && (d > c && g < h || g > c && d < h) ? a = !0 : y > u && (u = y) } var v = []; if (a && u < l) { var _ = []; v.push(_); for (var m = 0; m < n.length; ++m) { var x = parseFloat(n[m][0]); if (m > 0 && Math.abs(x - n[m - 1][0]) > p) { var E = parseFloat(n[m - 1][0]), b = parseFloat(n[m - 1][1]), w = parseFloat(n[m][0]), I = parseFloat(n[m][1]); if (E > -180 && E < h && 180 === w && m + 1 < n.length && n[m - 1][0] > -180 && n[m - 1][0] < h) { _.push([-180, n[m][1]]), m++, _.push([n[m][0], n[m][1]]); continue } if (E > c && E < 180 && -180 === w && m + 1 < n.length && n[m - 1][0] > c && n[m - 1][0] < 180) { _.push([180, n[m][1]]), m++, _.push([n[m][0], n[m][1]]); continue } if (E < h && w > c) { var N = E; E = w, w = N; var S = b; b = I, I = S } if (E > c && w < h && (w += 360), E <= 180 && w >= 180 && E < w) { var C = (180 - E) / (w - E), P = C * I + (1 - C) * b; _.push([n[m - 1][0] > c ? 180 : -180, P]), (_ = []).push([n[m - 1][0] > c ? -180 : 180, P]), v.push(_) } else _ = [], v.push(_); _.push([x, n[m][1]]) } else _.push([n[m][0], n[m][1]]) } } else { var L = []; v.push(L); for (var M = 0; M < n.length; ++M)L.push([n[M][0], n[M][1]]) } for (var O = new fi(this.properties), R = 0; R < v.length; ++R) { var T = new pi; O.geometries.push(T); for (var A = v[R], D = 0; D < A.length; ++D)T.move_to(A[D]) } return O }; var Oi = Bt((function (t, e) { function n(t) { var e = []; for (var n in t) e.push(n); return e } (t.exports = "function" == typeof Object.keys ? Object.keys : n).shim = n })), Ri = Bt((function (t, e) { var n = "[object Arguments]" == function () { return Object.prototype.toString.call(arguments) }(); function r(t) { return "[object Arguments]" == Object.prototype.toString.call(t) } function i(t) { return t && "object" == typeof t && "number" == typeof t.length && Object.prototype.hasOwnProperty.call(t, "callee") && !Object.prototype.propertyIsEnumerable.call(t, "callee") || !1 } (e = t.exports = n ? r : i).supported = r, e.unsupported = i })), Ti = Bt((function (t) { var e = Array.prototype.slice, n = t.exports = function (t, o, s) { return s || (s = {}), t === o || (t instanceof Date && o instanceof Date ? t.getTime() === o.getTime() : !t || !o || "object" != typeof t && "object" != typeof o ? s.strict ? t === o : t == o : function (t, o, s) { var a, u; if (r(t) || r(o)) return !1; if (t.prototype !== o.prototype) return !1; if (Ri(t)) return !!Ri(o) && (t = e.call(t), o = e.call(o), n(t, o, s)); if (i(t)) { if (!i(o)) return !1; if (t.length !== o.length) return !1; for (a = 0; a < t.length; a++)if (t[a] !== o[a]) return !1; return !0 } try { var l = Oi(t), c = Oi(o) } catch (t) { return !1 } if (l.length != c.length) return !1; for (l.sort(), c.sort(), a = l.length - 1; a >= 0; a--)if (l[a] != c[a]) return !1; for (a = l.length - 1; a >= 0; a--)if (u = l[a], !n(t[u], o[u], s)) return !1; return typeof t == typeof o }(t, o, s)) }; function r(t) { return null == t } function i(t) { return !(!t || "object" != typeof t || "number" != typeof t.length) && ("function" == typeof t.copy && "function" == typeof t.slice && !(t.length > 0 && "number" != typeof t[0])) } })); function Ai(t, e, n) { if (void 0 === n && (n = {}), !P(n = n || {})) throw new Error("options is invalid"); var r, i = n.tolerance || 0, o = [], s = Pr(), a = Jn(t); return s.load(a), Q(e, (function (t) { var e = !1; X(s.search(t), (function (n) { if (!1 === e) { var o = T(t).sort(), s = T(n).sort(); Ti(o, s) || (0 === i ? Hr(o[0], n) && Hr(o[1], n) : Rr(n, o[0]).properties.dist <= i && Rr(n, o[1]).properties.dist <= i) ? (e = !0, r = r ? Di(r, t) : t) : (0 === i ? Hr(s[0], t) && Hr(s[1], t) : Rr(t, s[0]).properties.dist <= i && Rr(t, s[1]).properties.dist <= i) && (r = r ? Di(r, n) : n) } })), !1 === e && r && (o.push(r), r = void 0) })), r && o.push(r), f(o) } function Di(t, e) { var n = T(e), r = T(t), i = r[0], o = r[r.length - 1], s = t.geometry.coordinates; return Ti(n[0], i) ? s.unshift(n[1]) : Ti(n[0], o) ? s.push(n[1]) : Ti(n[1], i) ? s.unshift(n[0]) : Ti(n[1], o) && s.push(n[0]), t } function Fi(t) { var e = t % 360; return e < 0 && (e += 360), e } function ki(t, e, n) { var r; return void 0 === n && (n = {}), (r = n.final ? Gi(R(e), R(t)) : Gi(R(t), R(e))) > 180 ? -(360 - r) : r } function Gi(t, e) { var n = I(t[1]), r = I(e[1]), i = I(e[0] - t[0]); i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI); var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4)); return (w(Math.atan2(i, o)) + 360) % 360 } function qi(t, n, r, i) { void 0 === i && (i = {}); var o = n < 0, s = N(Math.abs(n), i.units, "meters"); o && (s = -Math.abs(s)); var u = R(t), l = function (t, n, r, i) { i = void 0 === i ? e : Number(i); var o = n / i, s = t[0] * Math.PI / 180, a = I(t[1]), u = I(r), l = o * Math.cos(u), c = a + l; Math.abs(c) > Math.PI / 2 && (c = c > 0 ? Math.PI - c : -Math.PI - c); var h = Math.log(Math.tan(c / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)), p = Math.abs(h) > 1e-11 ? l / h : Math.cos(a), f = o * Math.sin(u) / p; return [(180 * (s + f) / Math.PI + 540) % 360 - 180, 180 * c / Math.PI] }(u, s, r); return l[0] += l[0] - u[0] > 180 ? -360 : u[0] - l[0] > 180 ? 360 : 0, a(l, i.properties) } function Bi(t, e, n, r, i, o) { for (var s = 0; s < t.length; s++) { var a = t[s], u = t[s + 1]; s === t.length - 1 && (u = t[0]), r = ji(a, u, e), n <= 0 && r > 0 ? ji(e, a, i) < 0 || (i = a) : n > 0 && r <= 0 && (zi(e, a, o) || (o = a)), n = r } return [i, o] } function zi(t, e, n) { return ji(t, e, n) > 0 } function ji(t, e, n) { return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1]) } function Ui(t) { for (var e, n, r = T(t), i = 0, o = 1; o < r.length;)e = n || r[0], i += ((n = r[o])[0] - e[0]) * (n[1] + e[1]), o++; return i > 0 } function Vi(t, e) { switch ("Feature" === t.type ? t.geometry.type : t.type) { case "GeometryCollection": return W(t, (function (t) { Vi(t, e) })), t; case "LineString": return Xi(T(t), e), t; case "Polygon": return Yi(T(t), e), t; case "MultiLineString": return T(t).forEach((function (t) { Xi(t, e) })), t; case "MultiPolygon": return T(t).forEach((function (t) { Yi(t, e) })), t; case "Point": case "MultiPoint": return t } } function Xi(t, e) { Ui(t) === e && t.reverse() } function Yi(t, e) { Ui(t[0]) !== e && t[0].reverse(); for (var n = 1; n < t.length; n++)Ui(t[n]) === e && t[n].reverse() } function Hi(t, e) {
        if (!P(e = e || {})) throw new Error("options is invalid"); var n = e.zProperty || "elevation", r = e.flip, i = e.flags; k(t, "Point", "input must contain Points"); for (var o = function (t, e) { var n = {}; return X(t, (function (t) { var e = T(t)[1]; n[e] || (n[e] = []), n[e].push(t) })), Object.keys(n).map((function (t) { return n[t].sort((function (t, e) { return T(t)[0] - T(e)[0] })) })).sort((function (t, n) { return e ? T(t[0])[1] - T(n[0])[1] : T(n[0])[1] - T(t[0])[1] })) }
/*!
     * @license GNU Affero General Public License.
     * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
     * v. 1.2.0
     * https://github.com/RaumZeit/MarchingSquares.js
     *
     * MarchingSquaresJS is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Affero General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * MarchingSquaresJS is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU Affero General Public License for more details.
     *
     * As additional permission under GNU Affero General Public License version 3
     * section 7, third-party projects (personal or commercial) may distribute,
     * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
     * requirement that said third-party project for that reason alone becomes
     * subject to any requirement of the GNU Affero General Public License version 3.
     * Any modifications to MarchingSquaresJS, however, must be shared with the public
     * and made available.
     *
     * In summary this:
     * - allows you to use MarchingSquaresJS at no cost
     * - allows you to use MarchingSquaresJS for both personal and commercial purposes
     * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
     *   license as long as this license notice is included
     * - enables you to keep the source code of your program that uses MarchingSquaresJS
     *   undisclosed
     * - forces you to share any modifications you have made to MarchingSquaresJS,
     *   e.g. bug-fixes
     *
     * You should have received a copy of the GNU Affero General Public License
     * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
     */(t, r), s = [], a = 0; a < o.length; a++) { for (var u = o[a], l = [], c = 0; c < u.length; c++) { var h = u[c]; h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [a, c]) } s.push(l) } return s
    } var Wi = { successCallback: null, verbose: !1, polygons: !1 }, Ji = {}; function Zi(t, e, n, r) { r = r || {}; for (var i = Object.keys(Wi), o = 0; o < i.length; o++) { var s = i[o], a = r[s]; a = null != a ? a : Wi[s], Ji[s] = a } Ji.verbose && console.log("MarchingSquaresJS-isoBands: computing isobands for [" + e + ":" + (e + n) + "]"); var u, l = function (t, e, n) { for (var r = t.length - 1, i = t[0].length - 1, o = { rows: r, cols: i, cells: [] }, s = e + Math.abs(n), a = 0; a < r; ++a) { o.cells[a] = []; for (var u = 0; u < i; ++u) { var l = 0, c = t[a + 1][u], h = t[a + 1][u + 1], p = t[a][u + 1], f = t[a][u]; if (!(isNaN(c) || isNaN(h) || isNaN(p) || isNaN(f))) { l |= c < e ? 0 : c > s ? 128 : 64, l |= h < e ? 0 : h > s ? 32 : 16, l |= p < e ? 0 : p > s ? 8 : 4; var g = +(l |= f < e ? 0 : f > s ? 2 : 1), d = 0; if (17 === l || 18 === l || 33 === l || 34 === l || 38 === l || 68 === l || 72 === l || 98 === l || 102 === l || 132 === l || 136 === l || 137 === l || 152 === l || 153 === l) { var y = (c + h + p + f) / 4; d = y > s ? 2 : y < e ? 0 : 1, 34 === l ? 1 === d ? l = 35 : 0 === d && (l = 136) : 136 === l ? 1 === d ? (l = 35, d = 4) : 0 === d && (l = 34) : 17 === l ? 1 === d ? (l = 155, d = 4) : 0 === d && (l = 153) : 68 === l ? 1 === d ? (l = 103, d = 4) : 0 === d && (l = 102) : 153 === l ? 1 === d && (l = 155) : 102 === l ? 1 === d && (l = 103) : 152 === l ? d < 2 && (l = 156, d = 1) : 137 === l ? d < 2 && (l = 139, d = 1) : 98 === l ? d < 2 && (l = 99, d = 1) : 38 === l ? d < 2 && (l = 39, d = 1) : 18 === l ? d > 0 ? (l = 156, d = 4) : l = 152 : 33 === l ? d > 0 ? (l = 139, d = 4) : l = 137 : 72 === l ? d > 0 ? (l = 99, d = 4) : l = 98 : 132 === l && (d > 0 ? (l = 39, d = 4) : l = 38) } if (0 != l && 170 != l) { var v, _, m, x, E, b, w, I; v = _ = m = x = E = b = w = I = .5; var N = []; 1 === l ? (m = 1 - zo(e, p, f), I = 1 - zo(e, c, f), N.push(Do[l])) : 169 === l ? (m = zo(s, f, p), I = zo(s, f, c), N.push(Do[l])) : 4 === l ? (b = 1 - zo(e, h, p), x = zo(e, f, p), N.push(To[l])) : 166 === l ? (b = zo(s, p, h), x = 1 - zo(s, p, f), N.push(To[l])) : 16 === l ? (E = zo(e, p, h), _ = zo(e, c, h), N.push(Ro[l])) : 154 === l ? (E = 1 - zo(s, h, p), _ = 1 - zo(s, h, c), N.push(Ro[l])) : 64 === l ? (w = zo(e, f, c), v = 1 - zo(e, h, c), N.push(ko[l])) : 106 === l ? (w = 1 - zo(s, c, f), v = zo(s, c, h), N.push(ko[l])) : 168 === l ? (x = zo(s, f, p), m = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), N.push(Ao[l]), N.push(Do[l])) : 2 === l ? (x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), N.push(Ao[l]), N.push(Do[l])) : 162 === l ? (E = zo(s, p, h), b = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), N.push(Ao[l]), N.push(Do[l])) : 8 === l ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), N.push(Ro[l]), N.push(To[l])) : 138 === l ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c), N.push(Ro[l]), N.push(To[l])) : 32 === l ? (E = zo(s, p, h), b = zo(e, p, h), v = zo(e, c, h), _ = zo(s, c, h), N.push(Ro[l]), N.push(To[l])) : 42 === l ? (I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h), N.push(Fo[l]), N.push(ko[l])) : 128 === l && (I = zo(e, f, c), w = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c), N.push(Fo[l]), N.push(ko[l])), 5 === l ? (b = 1 - zo(e, h, p), I = 1 - zo(e, c, f), N.push(To[l])) : 165 === l ? (b = zo(s, p, h), I = zo(s, f, c), N.push(To[l])) : 20 === l ? (x = zo(e, f, p), _ = zo(e, c, h), N.push(Ao[l])) : 150 === l ? (x = 1 - zo(s, p, f), _ = 1 - zo(s, h, c), N.push(Ao[l])) : 80 === l ? (E = zo(e, p, h), w = zo(e, f, c), N.push(Ro[l])) : 90 === l ? (E = 1 - zo(s, h, p), w = 1 - zo(s, c, f), N.push(Ro[l])) : 65 === l ? (m = 1 - zo(e, p, f), v = 1 - zo(e, h, c), N.push(Do[l])) : 105 === l ? (m = zo(s, f, p), v = zo(s, c, h), N.push(Do[l])) : 160 === l ? (E = zo(s, p, h), b = zo(e, p, h), I = zo(e, f, c), w = zo(s, f, c), N.push(Ro[l]), N.push(To[l])) : 10 === l ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), N.push(Ro[l]), N.push(To[l])) : 130 === l ? (x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c), N.push(Ao[l]), N.push(Do[l])) : 40 === l ? (x = zo(s, f, p), m = zo(e, f, p), v = zo(e, c, h), _ = zo(s, c, h), N.push(Ao[l]), N.push(Do[l])) : 101 === l ? (b = zo(s, p, h), v = zo(s, c, h), N.push(To[l])) : 69 === l ? (b = 1 - zo(e, h, p), v = 1 - zo(e, h, c), N.push(To[l])) : 149 === l ? (I = zo(s, f, c), _ = 1 - zo(s, h, c), N.push(Fo[l])) : 21 === l ? (I = 1 - zo(e, c, f), _ = zo(e, c, h), N.push(Fo[l])) : 86 === l ? (x = 1 - zo(s, p, f), w = 1 - zo(s, c, f), N.push(Ao[l])) : 84 === l ? (x = zo(e, f, p), w = zo(e, f, c), N.push(Ao[l])) : 89 === l ? (E = 1 - zo(s, h, p), m = zo(s, f, p), N.push(Do[l])) : 81 === l ? (E = zo(e, p, h), m = 1 - zo(e, p, f), N.push(Do[l])) : 96 === l ? (E = zo(s, p, h), b = zo(e, p, h), w = zo(e, f, c), v = zo(s, c, h), N.push(Ro[l]), N.push(To[l])) : 74 === l ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), w = 1 - zo(s, c, f), v = 1 - zo(e, h, c), N.push(Ro[l]), N.push(To[l])) : 24 === l ? (E = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), _ = zo(e, c, h), N.push(Ro[l]), N.push(Do[l])) : 146 === l ? (E = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), _ = 1 - zo(s, h, c), N.push(Ro[l]), N.push(Do[l])) : 6 === l ? (b = 1 - zo(e, h, p), x = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), N.push(To[l]), N.push(Ao[l])) : 164 === l ? (b = zo(s, p, h), x = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), N.push(To[l]), N.push(Ao[l])) : 129 === l ? (m = 1 - zo(e, p, f), I = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c), N.push(Do[l]), N.push(Fo[l])) : 41 === l ? (m = zo(s, f, p), I = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h), N.push(Do[l]), N.push(Fo[l])) : 66 === l ? (x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), w = 1 - zo(s, c, f), v = 1 - zo(e, h, c), N.push(Ao[l]), N.push(Do[l])) : 104 === l ? (x = zo(s, f, p), m = zo(e, f, p), w = zo(e, f, c), v = zo(s, c, h), N.push(Do[l]), N.push(Go[l])) : 144 === l ? (E = zo(e, p, h), I = zo(e, f, c), w = zo(s, f, c), _ = 1 - zo(s, h, c), N.push(Ro[l]), N.push(ko[l])) : 26 === l ? (E = 1 - zo(s, h, p), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), _ = zo(e, c, h), N.push(Ro[l]), N.push(ko[l])) : 36 === l ? (b = zo(s, p, h), x = zo(e, f, p), v = zo(e, c, h), _ = zo(s, c, h), N.push(To[l]), N.push(Ao[l])) : 134 === l ? (b = 1 - zo(e, h, p), x = 1 - zo(s, p, f), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c), N.push(To[l]), N.push(Ao[l])) : 9 === l ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), m = zo(s, f, p), I = 1 - zo(e, c, f), N.push(Ro[l]), N.push(To[l])) : 161 === l ? (E = zo(s, p, h), b = zo(e, p, h), m = 1 - zo(e, p, f), I = zo(s, f, c), N.push(Ro[l]), N.push(To[l])) : 37 === l ? (b = zo(s, p, h), I = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h), N.push(To[l]), N.push(Fo[l])) : 133 === l ? (b = 1 - zo(e, h, p), I = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c), N.push(To[l]), N.push(Fo[l])) : 148 === l ? (x = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), _ = 1 - zo(s, h, c), N.push(Ao[l]), N.push(ko[l])) : 22 === l ? (x = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), _ = zo(e, c, h), N.push(Ao[l]), N.push(ko[l])) : 82 === l ? (E = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), w = 1 - zo(s, c, f), N.push(Ro[l]), N.push(Do[l])) : 88 === l ? (E = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), w = zo(e, f, c), N.push(Ro[l]), N.push(Do[l])) : 73 === l ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), m = zo(s, f, p), v = 1 - zo(e, h, c), N.push(Ro[l]), N.push(To[l])) : 97 === l ? (E = zo(s, p, h), b = zo(e, p, h), m = 1 - zo(e, p, f), v = zo(s, c, h), N.push(Ro[l]), N.push(To[l])) : 145 === l ? (E = zo(e, p, h), m = 1 - zo(e, p, f), I = zo(s, f, c), _ = 1 - zo(s, h, c), N.push(Ro[l]), N.push(Fo[l])) : 25 === l ? (E = 1 - zo(s, h, p), m = zo(s, f, p), I = 1 - zo(e, c, f), _ = zo(e, c, h), N.push(Ro[l]), N.push(Fo[l])) : 70 === l ? (b = 1 - zo(e, h, p), x = 1 - zo(s, p, f), w = 1 - zo(s, c, f), v = 1 - zo(e, h, c), N.push(To[l]), N.push(Ao[l])) : 100 === l ? (b = zo(s, p, h), x = zo(e, f, p), w = zo(e, f, c), v = zo(s, c, h), N.push(To[l]), N.push(Ao[l])) : 34 === l ? (0 === d ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)) : (E = zo(s, p, h), b = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)), N.push(Ro[l]), N.push(To[l]), N.push(Fo[l]), N.push(ko[l])) : 35 === l ? (4 === d ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)) : (E = zo(s, p, h), b = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)), N.push(Ro[l]), N.push(To[l]), N.push(Do[l]), N.push(ko[l])) : 136 === l ? (0 === d ? (E = zo(s, p, h), b = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)) : (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)), N.push(Ro[l]), N.push(To[l]), N.push(Fo[l]), N.push(ko[l])) : 153 === l ? (0 === d ? (E = zo(e, p, h), m = 1 - zo(e, p, f), I = 1 - zo(e, c, f), _ = zo(e, c, h)) : (E = 1 - zo(s, h, p), m = zo(s, f, p), I = zo(s, f, c), _ = 1 - zo(s, h, c)), N.push(Ro[l]), N.push(Do[l])) : 102 === l ? (0 === d ? (b = 1 - zo(e, h, p), x = zo(e, f, p), w = zo(e, f, c), v = 1 - zo(e, h, c)) : (b = zo(s, p, h), x = 1 - zo(s, p, f), w = 1 - zo(s, c, f), v = zo(s, c, h)), N.push(To[l]), N.push(ko[l])) : 155 === l ? (4 === d ? (E = zo(e, p, h), m = 1 - zo(e, p, f), I = 1 - zo(e, c, f), _ = zo(e, c, h)) : (E = 1 - zo(s, h, p), m = zo(s, f, p), I = zo(s, f, c), _ = 1 - zo(s, h, c)), N.push(Ro[l]), N.push(Fo[l])) : 103 === l ? (4 === d ? (b = 1 - zo(e, h, p), x = zo(e, f, p), w = zo(e, f, c), v = 1 - zo(e, h, c)) : (b = zo(s, p, h), x = 1 - zo(s, p, f), w = 1 - zo(s, c, f), v = zo(s, c, h)), N.push(To[l]), N.push(Ao[l])) : 152 === l ? (0 === d ? (E = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), _ = zo(e, c, h)) : (E = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), _ = 1 - zo(s, h, c)), N.push(Ro[l]), N.push(Ao[l]), N.push(Do[l])) : 156 === l ? (4 === d ? (E = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), _ = zo(e, c, h)) : (E = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), _ = 1 - zo(s, h, c)), N.push(Ro[l]), N.push(Do[l]), N.push(ko[l])) : 137 === l ? (0 === d ? (E = zo(s, p, h), b = zo(e, p, h), m = 1 - zo(e, p, f), I = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)) : (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), m = zo(s, f, p), I = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)), N.push(Ro[l]), N.push(To[l]), N.push(Do[l])) : 139 === l ? (4 === d ? (E = zo(s, p, h), b = zo(e, p, h), m = 1 - zo(e, p, f), I = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)) : (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), m = zo(s, f, p), I = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)), N.push(Ro[l]), N.push(To[l]), N.push(Fo[l])) : 98 === l ? (0 === d ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), w = zo(e, f, c), v = 1 - zo(e, h, c)) : (E = zo(s, p, h), b = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), w = 1 - zo(s, c, f), v = zo(s, c, h)), N.push(Ro[l]), N.push(To[l]), N.push(ko[l])) : 99 === l ? (4 === d ? (E = 1 - zo(e, h, p), b = 1 - zo(s, h, p), x = zo(s, f, p), m = zo(e, f, p), w = zo(e, f, c), v = 1 - zo(e, h, c)) : (E = zo(s, p, h), b = zo(e, p, h), x = 1 - zo(e, p, f), m = 1 - zo(s, p, f), w = 1 - zo(s, c, f), v = zo(s, c, h)), N.push(Ro[l]), N.push(To[l]), N.push(Do[l])) : 38 === l ? (0 === d ? (b = 1 - zo(e, h, p), x = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)) : (b = zo(s, p, h), x = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)), N.push(To[l]), N.push(Fo[l]), N.push(ko[l])) : 39 === l ? (4 === d ? (b = 1 - zo(e, h, p), x = zo(e, f, p), I = zo(e, f, c), w = zo(s, f, c), v = 1 - zo(s, h, c), _ = 1 - zo(e, h, c)) : (b = zo(s, p, h), x = 1 - zo(s, p, f), I = 1 - zo(s, c, f), w = 1 - zo(e, c, f), v = zo(e, c, h), _ = zo(s, c, h)), N.push(To[l]), N.push(Ao[l]), N.push(ko[l])) : 85 === l && (E = 1, b = 0, x = 1, m = 0, I = 0, w = 1, v = 0, _ = 1), (v < 0 || v > 1 || _ < 0 || _ > 1 || E < 0 || E > 1 || x < 0 || x > 1 || I < 0 || I > 1 || w < 0 || w > 1) && console.log("MarchingSquaresJS-isoBands: " + l + " " + g + " " + c + "," + h + "," + p + "," + f + " " + d + " " + v + " " + _ + " " + E + " " + b + " " + x + " " + m + " " + I + " " + w), o.cells[a][u] = { cval: l, cval_real: g, flipped: d, topleft: v, topright: _, righttop: E, rightbottom: b, bottomright: x, bottomleft: m, leftbottom: I, lefttop: w, edges: N } } } } } return o }(t, e, n); return Ji.polygons ? (Ji.verbose && console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell"), u = function (t) { var e = [], n = 0; return t.cells.forEach((function (t, r) { t.forEach((function (t, i) { if (void 0 !== t) { var o = Bo[t.cval](t); "object" == typeof o && jo(o) ? "object" == typeof o[0] && jo(o[0]) ? "object" == typeof o[0][0] && jo(o[0][0]) ? o.forEach((function (t) { t.forEach((function (t) { t[0] += i, t[1] += r })), e[n++] = t })) : (o.forEach((function (t) { t[0] += i, t[1] += r })), e[n++] = o) : console.log("MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates") : console.log("MarchingSquaresJS-isoBands: bandcell polygon with null coordinates") } })) })), e }(l)) : (Ji.verbose && console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"), u = function (t) { for (var e = [], n = t.rows, r = t.cols, i = [], o = 0; o < n; o++)for (var s = 0; s < r; s++)if (void 0 !== t.cells[o][s] && t.cells[o][s].edges.length > 0) { var a = Vo(t.cells[o][s]), u = null, l = s, c = o; null !== a && i.push([a.p[0] + l, a.p[1] + c]); do { if (null === (u = Xo(t.cells[c][l], a.x, a.y, a.o))) break; if (i.push([u.p[0] + l, u.p[1] + c]), l += u.x, a = u, (c += u.y) < 0 || c >= n || l < 0 || l >= r || void 0 === t.cells[c][l]) { var h = Uo(t, l -= u.x, c -= u.y, u.x, u.y, u.o); if (null === h) break; h.path.forEach((function (t) { i.push(t) })), l = h.i, c = h.j, a = h } } while (void 0 !== t.cells[c][l] && t.cells[c][l].edges.length > 0); e.push(i), i = [], t.cells[o][s].edges.length > 0 && s-- } return e }(l)), "function" == typeof Ji.successCallback && Ji.successCallback(u), u } var Ki = 64, Qi = 16, $i = [], to = [], eo = [], no = [], ro = [], io = [], oo = [], so = [], ao = [], uo = [], lo = [], co = [], ho = [], po = [], fo = [], go = [], yo = [], vo = [], _o = [], mo = [], xo = [], Eo = [], bo = [], wo = []; oo[85] = uo[85] = -1, so[85] = lo[85] = 0, ao[85] = co[85] = 1, _o[85] = Eo[85] = 1, mo[85] = bo[85] = 0, xo[85] = wo[85] = 1, $i[85] = no[85] = 0, to[85] = ro[85] = -1, eo[85] = fo[85] = 0, go[85] = ho[85] = 0, yo[85] = po[85] = 1, io[85] = vo[85] = 1, Eo[1] = Eo[169] = 0, bo[1] = bo[169] = -1, wo[1] = wo[169] = 0, ho[1] = ho[169] = -1, po[1] = po[169] = 0, fo[1] = fo[169] = 0, uo[4] = uo[166] = 0, lo[4] = lo[166] = -1, co[4] = co[166] = 1, go[4] = go[166] = 1, yo[4] = yo[166] = 0, vo[4] = vo[166] = 0, oo[16] = oo[154] = 0, so[16] = so[154] = 1, ao[16] = ao[154] = 1, no[16] = no[154] = 1, ro[16] = ro[154] = 0, io[16] = io[154] = 1, _o[64] = _o[106] = 0, mo[64] = mo[106] = 1, xo[64] = xo[106] = 0, $i[64] = $i[106] = -1, to[64] = to[106] = 0, eo[64] = eo[106] = 1, _o[2] = _o[168] = 0, mo[2] = mo[168] = -1, xo[2] = xo[168] = 1, Eo[2] = Eo[168] = 0, bo[2] = bo[168] = -1, wo[2] = wo[168] = 0, ho[2] = ho[168] = -1, po[2] = po[168] = 0, fo[2] = fo[168] = 0, go[2] = go[168] = -1, yo[2] = yo[168] = 0, vo[2] = vo[168] = 1, oo[8] = oo[162] = 0, so[8] = so[162] = -1, ao[8] = ao[162] = 0, uo[8] = uo[162] = 0, lo[8] = lo[162] = -1, co[8] = co[162] = 1, ho[8] = ho[162] = 1, po[8] = po[162] = 0, fo[8] = fo[162] = 1, go[8] = go[162] = 1, yo[8] = yo[162] = 0, vo[8] = vo[162] = 0, oo[32] = oo[138] = 0, so[32] = so[138] = 1, ao[32] = ao[138] = 1, uo[32] = uo[138] = 0, lo[32] = lo[138] = 1, co[32] = co[138] = 0, $i[32] = $i[138] = 1, to[32] = to[138] = 0, eo[32] = eo[138] = 0, no[32] = no[138] = 1, ro[32] = ro[138] = 0, io[32] = io[138] = 1, Eo[128] = Eo[42] = 0, bo[128] = bo[42] = 1, wo[128] = wo[42] = 1, _o[128] = _o[42] = 0, mo[128] = mo[42] = 1, xo[128] = xo[42] = 0, $i[128] = $i[42] = -1, to[128] = to[42] = 0, eo[128] = eo[42] = 1, no[128] = no[42] = -1, ro[128] = ro[42] = 0, io[128] = io[42] = 0, uo[5] = uo[165] = -1, lo[5] = lo[165] = 0, co[5] = co[165] = 0, Eo[5] = Eo[165] = 1, bo[5] = bo[165] = 0, wo[5] = wo[165] = 0, go[20] = go[150] = 0, yo[20] = yo[150] = 1, vo[20] = vo[150] = 1, no[20] = no[150] = 0, ro[20] = ro[150] = -1, io[20] = io[150] = 1, oo[80] = oo[90] = -1, so[80] = so[90] = 0, ao[80] = ao[90] = 1, _o[80] = _o[90] = 1, mo[80] = mo[90] = 0, xo[80] = xo[90] = 1, ho[65] = ho[105] = 0, po[65] = po[105] = 1, fo[65] = fo[105] = 0, $i[65] = $i[105] = 0, to[65] = to[105] = -1, eo[65] = eo[105] = 0, oo[160] = oo[10] = -1, so[160] = so[10] = 0, ao[160] = ao[10] = 1, uo[160] = uo[10] = -1, lo[160] = lo[10] = 0, co[160] = co[10] = 0, Eo[160] = Eo[10] = 1, bo[160] = bo[10] = 0, wo[160] = wo[10] = 0, _o[160] = _o[10] = 1, mo[160] = mo[10] = 0, xo[160] = xo[10] = 1, go[130] = go[40] = 0, yo[130] = yo[40] = 1, vo[130] = vo[40] = 1, ho[130] = ho[40] = 0, po[130] = po[40] = 1, fo[130] = fo[40] = 0, $i[130] = $i[40] = 0, to[130] = to[40] = -1, eo[130] = eo[40] = 0, no[130] = no[40] = 0, ro[130] = ro[40] = -1, io[130] = io[40] = 1, uo[37] = uo[133] = 0, lo[37] = lo[133] = 1, co[37] = co[133] = 1, Eo[37] = Eo[133] = 0, bo[37] = bo[133] = 1, wo[37] = wo[133] = 0, $i[37] = $i[133] = -1, to[37] = to[133] = 0, eo[37] = eo[133] = 0, no[37] = no[133] = 1, ro[37] = ro[133] = 0, io[37] = io[133] = 0, go[148] = go[22] = -1, yo[148] = yo[22] = 0, vo[148] = vo[22] = 0, Eo[148] = Eo[22] = 0, bo[148] = bo[22] = -1, wo[148] = wo[22] = 1, _o[148] = _o[22] = 0, mo[148] = mo[22] = 1, xo[148] = xo[22] = 1, no[148] = no[22] = -1, ro[148] = ro[22] = 0, io[148] = io[22] = 1, oo[82] = oo[88] = 0, so[82] = so[88] = -1, ao[82] = ao[88] = 1, go[82] = go[88] = 1, yo[82] = yo[88] = 0, vo[82] = vo[88] = 1, ho[82] = ho[88] = -1, po[82] = po[88] = 0, fo[82] = fo[88] = 1, _o[82] = _o[88] = 0, mo[82] = mo[88] = -1, xo[82] = xo[88] = 0, oo[73] = oo[97] = 0, so[73] = so[97] = 1, ao[73] = ao[97] = 0, uo[73] = uo[97] = 0, lo[73] = lo[97] = -1, co[73] = co[97] = 0, ho[73] = ho[97] = 1, po[73] = po[97] = 0, fo[73] = fo[97] = 0, $i[73] = $i[97] = 1, to[73] = to[97] = 0, eo[73] = eo[97] = 1, oo[145] = oo[25] = 0, so[145] = so[25] = -1, ao[145] = ao[25] = 0, ho[145] = ho[25] = 1, po[145] = po[25] = 0, fo[145] = fo[25] = 1, Eo[145] = Eo[25] = 0, bo[145] = bo[25] = 1, wo[145] = wo[25] = 1, no[145] = no[25] = -1, ro[145] = ro[25] = 0, io[145] = io[25] = 0, uo[70] = uo[100] = 0, lo[70] = lo[100] = 1, co[70] = co[100] = 0, go[70] = go[100] = -1, yo[70] = yo[100] = 0, vo[70] = vo[100] = 1, _o[70] = _o[100] = 0, mo[70] = mo[100] = -1, xo[70] = xo[100] = 1, $i[70] = $i[100] = 1, to[70] = to[100] = 0, eo[70] = eo[100] = 0, uo[101] = uo[69] = 0, lo[101] = lo[69] = 1, co[101] = co[69] = 0, $i[101] = $i[69] = 1, to[101] = to[69] = 0, eo[101] = eo[69] = 0, Eo[149] = Eo[21] = 0, bo[149] = bo[21] = 1, wo[149] = wo[21] = 1, no[149] = no[21] = -1, ro[149] = ro[21] = 0, io[149] = io[21] = 0, go[86] = go[84] = -1, yo[86] = yo[84] = 0, vo[86] = vo[84] = 1, _o[86] = _o[84] = 0, mo[86] = mo[84] = -1, xo[86] = xo[84] = 1, oo[89] = oo[81] = 0, so[89] = so[81] = -1, ao[89] = ao[81] = 0, ho[89] = ho[81] = 1, po[89] = po[81] = 0, fo[89] = fo[81] = 1, oo[96] = oo[74] = 0, so[96] = so[74] = 1, ao[96] = ao[74] = 0, uo[96] = uo[74] = -1, lo[96] = lo[74] = 0, co[96] = co[74] = 1, _o[96] = _o[74] = 1, mo[96] = mo[74] = 0, xo[96] = xo[74] = 0, $i[96] = $i[74] = 1, to[96] = to[74] = 0, eo[96] = eo[74] = 1, oo[24] = oo[146] = 0, so[24] = so[146] = -1, ao[24] = ao[146] = 1, go[24] = go[146] = 1, yo[24] = yo[146] = 0, vo[24] = vo[146] = 1, ho[24] = ho[146] = 0, po[24] = po[146] = 1, fo[24] = fo[146] = 1, no[24] = no[146] = 0, ro[24] = ro[146] = -1, io[24] = io[146] = 0, uo[6] = uo[164] = -1, lo[6] = lo[164] = 0, co[6] = co[164] = 1, go[6] = go[164] = -1, yo[6] = yo[164] = 0, vo[6] = vo[164] = 0, Eo[6] = Eo[164] = 0, bo[6] = bo[164] = -1, wo[6] = wo[164] = 1, _o[6] = _o[164] = 1, mo[6] = mo[164] = 0, xo[6] = xo[164] = 0, ho[129] = ho[41] = 0, po[129] = po[41] = 1, fo[129] = fo[41] = 1, Eo[129] = Eo[41] = 0, bo[129] = bo[41] = 1, wo[129] = wo[41] = 0, $i[129] = $i[41] = -1, to[129] = to[41] = 0, eo[129] = eo[41] = 0, no[129] = no[41] = 0, ro[129] = ro[41] = -1, io[129] = io[41] = 0, go[66] = go[104] = 0, yo[66] = yo[104] = 1, vo[66] = vo[104] = 0, ho[66] = ho[104] = -1, po[66] = po[104] = 0, fo[66] = fo[104] = 1, _o[66] = _o[104] = 0, mo[66] = mo[104] = -1, xo[66] = xo[104] = 0, $i[66] = $i[104] = 0, to[66] = to[104] = -1, eo[66] = eo[104] = 1, oo[144] = oo[26] = -1, so[144] = so[26] = 0, ao[144] = ao[26] = 0, Eo[144] = Eo[26] = 1, bo[144] = bo[26] = 0, wo[144] = wo[26] = 1, _o[144] = _o[26] = 0, mo[144] = mo[26] = 1, xo[144] = xo[26] = 1, no[144] = no[26] = -1, ro[144] = ro[26] = 0, io[144] = io[26] = 1, uo[36] = uo[134] = 0, lo[36] = lo[134] = 1, co[36] = co[134] = 1, go[36] = go[134] = 0, yo[36] = yo[134] = 1, vo[36] = vo[134] = 0, $i[36] = $i[134] = 0, to[36] = to[134] = -1, eo[36] = eo[134] = 1, no[36] = no[134] = 1, ro[36] = ro[134] = 0, io[36] = io[134] = 0, oo[9] = oo[161] = -1, so[9] = so[161] = 0, ao[9] = ao[161] = 0, uo[9] = uo[161] = 0, lo[9] = lo[161] = -1, co[9] = co[161] = 0, ho[9] = ho[161] = 1, po[9] = po[161] = 0, fo[9] = fo[161] = 0, Eo[9] = Eo[161] = 1, bo[9] = bo[161] = 0, wo[9] = wo[161] = 1, oo[136] = 0, so[136] = 1, ao[136] = 1, uo[136] = 0, lo[136] = 1, co[136] = 0, go[136] = -1, yo[136] = 0, vo[136] = 1, ho[136] = -1, po[136] = 0, fo[136] = 0, Eo[136] = 0, bo[136] = -1, wo[136] = 0, _o[136] = 0, mo[136] = -1, xo[136] = 1, $i[136] = 1, to[136] = 0, eo[136] = 0, no[136] = 1, ro[136] = 0, io[136] = 1, oo[34] = 0, so[34] = -1, ao[34] = 0, uo[34] = 0, lo[34] = -1, co[34] = 1, go[34] = 1, yo[34] = 0, vo[34] = 0, ho[34] = 1, po[34] = 0, fo[34] = 1, Eo[34] = 0, bo[34] = 1, wo[34] = 1, _o[34] = 0, mo[34] = 1, xo[34] = 0, $i[34] = -1, to[34] = 0, eo[34] = 1, no[34] = -1, ro[34] = 0, io[34] = 0, oo[35] = 0, so[35] = 1, ao[35] = 1, uo[35] = 0, lo[35] = -1, co[35] = 1, go[35] = 1, yo[35] = 0, vo[35] = 0, ho[35] = -1, po[35] = 0, fo[35] = 0, Eo[35] = 0, bo[35] = -1, wo[35] = 0, _o[35] = 0, mo[35] = 1, xo[35] = 0, $i[35] = -1, to[35] = 0, eo[35] = 1, no[35] = 1, ro[35] = 0, io[35] = 1, oo[153] = 0, so[153] = 1, ao[153] = 1, ho[153] = -1, po[153] = 0, fo[153] = 0, Eo[153] = 0, bo[153] = -1, wo[153] = 0, no[153] = 1, ro[153] = 0, io[153] = 1, uo[102] = 0, lo[102] = -1, co[102] = 1, go[102] = 1, yo[102] = 0, vo[102] = 0, _o[102] = 0, mo[102] = 1, xo[102] = 0, $i[102] = -1, to[102] = 0, eo[102] = 1, oo[155] = 0, so[155] = -1, ao[155] = 0, ho[155] = 1, po[155] = 0, fo[155] = 1, Eo[155] = 0, bo[155] = 1, wo[155] = 1, no[155] = -1, ro[155] = 0, io[155] = 0, uo[103] = 0, lo[103] = 1, co[103] = 0, go[103] = -1, yo[103] = 0, vo[103] = 1, _o[103] = 0, mo[103] = -1, xo[103] = 1, $i[103] = 1, to[103] = 0, eo[103] = 0, oo[152] = 0, so[152] = 1, ao[152] = 1, go[152] = -1, yo[152] = 0, vo[152] = 1, ho[152] = -1, po[152] = 0, fo[152] = 0, Eo[152] = 0, bo[152] = -1, wo[152] = 0, _o[152] = 0, mo[152] = -1, xo[152] = 1, no[152] = 1, ro[152] = 0, io[152] = 1, oo[156] = 0, so[156] = -1, ao[156] = 1, go[156] = 1, yo[156] = 0, vo[156] = 1, ho[156] = -1, po[156] = 0, fo[156] = 0, Eo[156] = 0, bo[156] = -1, wo[156] = 0, _o[156] = 0, mo[156] = 1, xo[156] = 1, no[156] = -1, ro[156] = 0, io[156] = 1, oo[137] = 0, so[137] = 1, ao[137] = 1, uo[137] = 0, lo[137] = 1, co[137] = 0, ho[137] = -1, po[137] = 0, fo[137] = 0, Eo[137] = 0, bo[137] = -1, wo[137] = 0, $i[137] = 1, to[137] = 0, eo[137] = 0, no[137] = 1, ro[137] = 0, io[137] = 1, oo[139] = 0, so[139] = 1, ao[139] = 1, uo[139] = 0, lo[139] = -1, co[139] = 0, ho[139] = 1, po[139] = 0, fo[139] = 0, Eo[139] = 0, bo[139] = 1, wo[139] = 0, $i[139] = -1, to[139] = 0, eo[139] = 0, no[139] = 1, ro[139] = 0, io[139] = 1, oo[98] = 0, so[98] = -1, ao[98] = 0, uo[98] = 0, lo[98] = -1, co[98] = 1, go[98] = 1, yo[98] = 0, vo[98] = 0, ho[98] = 1, po[98] = 0, fo[98] = 1, _o[98] = 0, mo[98] = 1, xo[98] = 0, $i[98] = -1, to[98] = 0, eo[98] = 1, oo[99] = 0, so[99] = 1, ao[99] = 0, uo[99] = 0, lo[99] = -1, co[99] = 1, go[99] = 1, yo[99] = 0, vo[99] = 0, ho[99] = -1, po[99] = 0, fo[99] = 1, _o[99] = 0, mo[99] = -1, xo[99] = 0, $i[99] = 1, to[99] = 0, eo[99] = 1, uo[38] = 0, lo[38] = -1, co[38] = 1, go[38] = 1, yo[38] = 0, vo[38] = 0, Eo[38] = 0, bo[38] = 1, wo[38] = 1, _o[38] = 0, mo[38] = 1, xo[38] = 0, $i[38] = -1, to[38] = 0, eo[38] = 1, no[38] = -1, ro[38] = 0, io[38] = 0, uo[39] = 0, lo[39] = 1, co[39] = 1, go[39] = -1, yo[39] = 0, vo[39] = 0, Eo[39] = 0, bo[39] = -1, wo[39] = 1, _o[39] = 0, mo[39] = 1, xo[39] = 0, $i[39] = -1, to[39] = 0, eo[39] = 1, no[39] = 1, ro[39] = 0, io[39] = 0; var Io = function (t) { return [[t.bottomleft, 0], [0, 0], [0, t.leftbottom]] }, No = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0]] }, So = function (t) { return [[t.topright, 1], [1, 1], [1, t.righttop]] }, Co = function (t) { return [[0, t.lefttop], [0, 1], [t.topleft, 1]] }, Po = function (t) { return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop]] }, Lo = function (t) { return [[t.bottomright, 0], [t.bottomleft, 0], [1, t.righttop], [1, t.rightbottom]] }, Mo = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.topleft, 1], [t.topright, 1]] }, Oo = function (t) { return [[0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]] }, Ro = [], To = [], Ao = [], Do = [], Fo = [], ko = [], Go = [], qo = []; Do[1] = Fo[1] = 18, Do[169] = Fo[169] = 18, Ao[4] = To[4] = 12, Ao[166] = To[166] = 12, Ro[16] = qo[16] = 4, Ro[154] = qo[154] = 4, ko[64] = Go[64] = 22, ko[106] = Go[106] = 22, Ao[2] = ko[2] = 17, Do[2] = Fo[2] = 18, Ao[168] = ko[168] = 17, Do[168] = Fo[168] = 18, Ro[8] = Do[8] = 9, To[8] = Ao[8] = 12, Ro[162] = Do[162] = 9, To[162] = Ao[162] = 12, Ro[32] = qo[32] = 4, To[32] = Go[32] = 1, Ro[138] = qo[138] = 4, To[138] = Go[138] = 1, Fo[128] = qo[128] = 21, ko[128] = Go[128] = 22, Fo[42] = qo[42] = 21, ko[42] = Go[42] = 22, To[5] = Fo[5] = 14, To[165] = Fo[165] = 14, Ao[20] = qo[20] = 6, Ao[150] = qo[150] = 6, Ro[80] = ko[80] = 11, Ro[90] = ko[90] = 11, Do[65] = Go[65] = 3, Do[105] = Go[105] = 3, Ro[160] = ko[160] = 11, To[160] = Fo[160] = 14, Ro[10] = ko[10] = 11, To[10] = Fo[10] = 14, Ao[130] = qo[130] = 6, Do[130] = Go[130] = 3, Ao[40] = qo[40] = 6, Do[40] = Go[40] = 3, To[101] = Go[101] = 1, To[69] = Go[69] = 1, Fo[149] = qo[149] = 21, Fo[21] = qo[21] = 21, Ao[86] = ko[86] = 17, Ao[84] = ko[84] = 17, Ro[89] = Do[89] = 9, Ro[81] = Do[81] = 9, Ro[96] = Go[96] = 0, To[96] = ko[96] = 15, Ro[74] = Go[74] = 0, To[74] = ko[74] = 15, Ro[24] = Ao[24] = 8, Do[24] = qo[24] = 7, Ro[146] = Ao[146] = 8, Do[146] = qo[146] = 7, To[6] = ko[6] = 15, Ao[6] = Fo[6] = 16, To[164] = ko[164] = 15, Ao[164] = Fo[164] = 16, Do[129] = qo[129] = 7, Fo[129] = Go[129] = 20, Do[41] = qo[41] = 7, Fo[41] = Go[41] = 20, Ao[66] = Go[66] = 2, Do[66] = ko[66] = 19, Ao[104] = Go[104] = 2, Do[104] = ko[104] = 19, Ro[144] = Fo[144] = 10, ko[144] = qo[144] = 23, Ro[26] = Fo[26] = 10, ko[26] = qo[26] = 23, To[36] = qo[36] = 5, Ao[36] = Go[36] = 2, To[134] = qo[134] = 5, Ao[134] = Go[134] = 2, Ro[9] = Fo[9] = 10, To[9] = Do[9] = 13, Ro[161] = Fo[161] = 10, To[161] = Do[161] = 13, To[37] = qo[37] = 5, Fo[37] = Go[37] = 20, To[133] = qo[133] = 5, Fo[133] = Go[133] = 20, Ao[148] = Fo[148] = 16, ko[148] = qo[148] = 23, Ao[22] = Fo[22] = 16, ko[22] = qo[22] = 23, Ro[82] = Ao[82] = 8, Do[82] = ko[82] = 19, Ro[88] = Ao[88] = 8, Do[88] = ko[88] = 19, Ro[73] = Go[73] = 0, To[73] = Do[73] = 13, Ro[97] = Go[97] = 0, To[97] = Do[97] = 13, Ro[145] = Do[145] = 9, Fo[145] = qo[145] = 21, Ro[25] = Do[25] = 9, Fo[25] = qo[25] = 21, To[70] = Go[70] = 1, Ao[70] = ko[70] = 17, To[100] = Go[100] = 1, Ao[100] = ko[100] = 17, Ro[34] = Do[34] = 9, To[34] = Ao[34] = 12, Fo[34] = qo[34] = 21, ko[34] = Go[34] = 22, Ro[136] = qo[136] = 4, To[136] = Go[136] = 1, Ao[136] = ko[136] = 17, Do[136] = Fo[136] = 18, Ro[35] = qo[35] = 4, To[35] = Ao[35] = 12, Do[35] = Fo[35] = 18, ko[35] = Go[35] = 22, Ro[153] = qo[153] = 4, Do[153] = Fo[153] = 18, To[102] = Ao[102] = 12, ko[102] = Go[102] = 22, Ro[155] = Do[155] = 9, Fo[155] = qo[155] = 23, To[103] = Go[103] = 1, Ao[103] = ko[103] = 17, Ro[152] = qo[152] = 4, Ao[152] = ko[152] = 17, Do[152] = Fo[152] = 18, Ro[156] = Ao[156] = 8, Do[156] = Fo[156] = 18, ko[156] = qo[156] = 23, Ro[137] = qo[137] = 4, To[137] = Go[137] = 1, Do[137] = Fo[137] = 18, Ro[139] = qo[139] = 4, To[139] = Do[139] = 13, Fo[139] = Go[139] = 20, Ro[98] = Do[98] = 9, To[98] = Ao[98] = 12, ko[98] = Go[98] = 22, Ro[99] = Go[99] = 0, To[99] = Ao[99] = 12, Do[99] = ko[99] = 19, To[38] = Ao[38] = 12, Fo[38] = qo[38] = 21, ko[38] = Go[38] = 22, To[39] = qo[39] = 5, Ao[39] = Fo[39] = 16, ko[39] = Go[39] = 22; var Bo = []; function zo(t, e, n) { return (t - e) / (n - e) } function jo(t) { return t.constructor.toString().indexOf("Array") > -1 } function Uo(t, e, n, r, i, o) { for (var s = t.cells[n][e], a = s.cval_real, u = e + r, l = n + i, c = [], h = !1; !h;) { if (void 0 === t.cells[l] || void 0 === t.cells[l][u]) if (l -= i, u -= r, a = (s = t.cells[l][u]).cval_real, -1 === i) if (0 === o) if (1 & a) c.push([u, l]), r = -1, i = 0, o = 0; else { if (!(4 & a)) { c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, h = !0; break } c.push([u + 1, l]), r = 1, i = 0, o = 0 } else { if (!(1 & a)) { if (4 & a) { c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, h = !0; break } c.push([u + s.bottomleft, l]), r = 0, i = 1, o = 0, h = !0; break } c.push([u, l]), r = -1, i = 0, o = 0 } else if (1 === i) if (0 === o) { if (!(a & Qi)) { if (a & Ki) { c.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, h = !0; break } c.push([u + s.topright, l + 1]), r = 0, i = -1, o = 1, h = !0; break } c.push([u + 1, l + 1]), r = 1, i = 0, o = 1 } else c.push([u + 1, l + 1]), r = 1, i = 0, o = 1; else if (-1 === r) if (0 === o) { if (!(a & Ki)) { if (1 & a) { c.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, h = !0; break } c.push([u, l + s.lefttop]), r = 1, i = 0, o = 1, h = !0; break } c.push([u, l + 1]), r = 0, i = 1, o = 0 } else { if (!(a & Ki)) { console.log("MarchingSquaresJS-isoBands: wtf"); break } c.push([u, l + 1]), r = 0, i = 1, o = 0 } else { if (1 !== r) { console.log("MarchingSquaresJS-isoBands: we came from nowhere!"); break } if (0 === o) { if (!(4 & a)) { c.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, h = !0; break } c.push([u + 1, l]), r = 0, i = -1, o = 1 } else { if (!(4 & a)) { if (a & Qi) { c.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1; break } c.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, h = !0; break } c.push([u + 1, l]), r = 0, i = -1, o = 1 } } else if (a = (s = t.cells[l][u]).cval_real, -1 === r) if (0 === o) if (void 0 !== t.cells[l - 1] && void 0 !== t.cells[l - 1][u]) r = 0, i = -1, o = 1; else { if (!(1 & a)) { c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, h = !0; break } c.push([u, l]) } else { if (!(a & Ki)) { console.log("MarchingSquaresJS-isoBands: found entry from top at " + u + "," + l); break } console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!") } else if (1 === r) { if (0 === o) { console.log("MarchingSquaresJS-isoBands: wtf"); break } if (void 0 !== t.cells[l + 1] && void 0 !== t.cells[l + 1][u]) r = 0, i = 1, o = 0; else { if (!(a & Qi)) { c.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, h = !0; break } c.push([u + 1, l + 1]), r = 1, i = 0, o = 1 } } else if (-1 === i) { if (1 !== o) { console.log("MarchingSquaresJS-isoBands: wtf"); break } if (void 0 !== t.cells[l][u + 1]) r = 1, i = 0, o = 1; else { if (!(4 & a)) { c.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1, h = !0; break } c.push([u + 1, l]), r = 0, i = -1, o = 1 } } else { if (1 !== i) { console.log("MarchingSquaresJS-isoBands: where did we came from???"); break } if (0 !== o) { console.log("MarchingSquaresJS-isoBands: wtf"); break } if (void 0 !== t.cells[l][u - 1]) r = -1, i = 0, o = 0; else { if (!(a & Ki)) { c.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, h = !0; break } c.push([u, l + 1]), r = 0, i = 1, o = 0 } } if (l += i, (u += r) === e && l === n) break } return { path: c, i: u, j: l, x: r, y: i, o: o } } function Vo(t) { if (t.edges.length > 0) { var e = t.edges[t.edges.length - 1], n = t.cval_real; switch (e) { case 0: return n & Qi ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [t.topleft, 1], x: 0, y: -1, o: 0 }; case 1: return 4 & n ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 2: return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [t.topleft, 1], x: 0, y: -1, o: 0 }; case 3: return 1 & n ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 4: return n & Qi ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; case 5: return 4 & n ? { p: [t.topright, 1], x: 0, y: -1, o: 1 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 6: return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; case 7: return 1 & n ? { p: [t.topright, 1], x: 0, y: -1, o: 1 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 8: return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [1, t.righttop], x: -1, y: 0, o: 1 }; case 9: return 1 & n ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 10: return 1 & n ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [1, t.righttop], x: -1, y: 0, o: 1 }; case 11: return n & Ki ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 12: return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 13: return 1 & n ? { p: [1, t.rightbottom], x: -1, y: 0, o: 0 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 14: return 1 & n ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 15: return n & Ki ? { p: [1, t.rightbottom], x: -1, y: 0, o: 0 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 16: return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [0, t.leftbottom], x: 1, y: 0, o: 0 }; case 17: return n & Ki ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 18: return 1 & n ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 19: return n & Ki ? { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 20: return n & Ki ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [0, t.leftbottom], x: 1, y: 0, o: 0 }; case 21: return n & Qi ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; case 22: return n & Ki ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 23: return n & Qi ? { p: [0, t.lefttop], x: 1, y: 0, o: 1 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; default: console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t) } } return null } function Xo(t, e, n, r) { var i, o, s, a, u, l = t.cval; switch (e) { case -1: switch (r) { case 0: i = To[l], s = uo[l], a = lo[l], u = co[l]; break; default: i = Ro[l], s = oo[l], a = so[l], u = ao[l] }break; case 1: switch (r) { case 0: i = Fo[l], s = Eo[l], a = bo[l], u = wo[l]; break; default: i = ko[l], s = _o[l], a = mo[l], u = xo[l] }break; default: switch (n) { case -1: switch (r) { case 0: i = Go[l], s = $i[l], a = to[l], u = eo[l]; break; default: i = qo[l], s = no[l], a = ro[l], u = io[l] }break; case 1: switch (r) { case 0: i = Do[l], s = ho[l], a = po[l], u = fo[l]; break; default: i = Ao[l], s = go[l], a = yo[l], u = vo[l] } } }if (o = t.edges.indexOf(i), void 0 === t.edges[o]) return null; switch (function (t, e) { delete t.edges[e]; for (var n = e + 1; n < t.edges.length; n++)t.edges[n - 1] = t.edges[n]; t.edges.pop() }(t, o), l = t.cval_real, i) { case 0: l & Qi ? (e = t.topleft, n = 1) : (e = 1, n = t.righttop); break; case 1: 4 & l ? (e = 1, n = t.rightbottom) : (e = t.topleft, n = 1); break; case 2: 4 & l ? (e = t.topleft, n = 1) : (e = t.bottomright, n = 0); break; case 3: 1 & l ? (e = t.bottomleft, n = 0) : (e = t.topleft, n = 1); break; case 4: l & Qi ? (e = t.topright, n = 1) : (e = 1, n = t.righttop); break; case 5: 4 & l ? (e = 1, n = t.rightbottom) : (e = t.topright, n = 1); break; case 6: 4 & l ? (e = t.topright, n = 1) : (e = t.bottomright, n = 0); break; case 7: 1 & l ? (e = t.bottomleft, n = 0) : (e = t.topright, n = 1); break; case 8: 4 & l ? (e = 1, n = t.righttop) : (e = t.bottomright, n = 0); break; case 9: 1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.righttop); break; case 10: 1 & l ? (e = 1, n = t.righttop) : (e = 0, n = t.leftbottom); break; case 11: l & Ki ? (e = 0, n = t.lefttop) : (e = 1, n = t.righttop); break; case 12: 4 & l ? (e = 1, n = t.rightbottom) : (e = t.bottomright, n = 0); break; case 13: 1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.rightbottom); break; case 14: 1 & l ? (e = 1, n = t.rightbottom) : (e = 0, n = t.leftbottom); break; case 15: l & Ki ? (e = 0, n = t.lefttop) : (e = 1, n = t.rightbottom); break; case 16: 4 & l ? (e = 0, n = t.leftbottom) : (e = t.bottomright, n = 0); break; case 17: l & Ki ? (e = 0, n = t.lefttop) : (e = t.bottomright, n = 0); break; case 18: 1 & l ? (e = t.bottomleft, n = 0) : (e = 0, n = t.leftbottom); break; case 19: l & Ki ? (e = 0, n = t.lefttop) : (e = t.bottomleft, n = 0); break; case 20: l & Ki ? (e = 0, n = t.leftbottom) : (e = t.topleft, n = 1); break; case 21: l & Qi ? (e = t.topright, n = 1) : (e = 0, n = t.leftbottom); break; case 22: l & Ki ? (e = 0, n = t.lefttop) : (e = t.topleft, n = 1); break; case 23: l & Qi ? (e = t.topright, n = 1) : (e = 0, n = t.lefttop); break; default: return console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t), null }return void 0 !== e && void 0 !== n && void 0 !== s && void 0 !== a && void 0 !== u || (console.log("MarchingSquaresJS-isoBands: undefined value!"), console.log(t), console.log(e + " " + n + " " + s + " " + a + " " + u)), { p: [e, n], x: s, y: a, o: u } } function Yo(t) { var e = [], n = []; t.forEach((function (t) { var r = zr(l([t])); n.push(r), e.push({ ring: t, area: r }) })), n.sort((function (t, e) { return e - t })); var r = []; return n.forEach((function (t) { for (var n = 0; n < e.length; n++)if (e[n].area === t) { r.push(e[n].ring), e.splice(n, 1); break } })), r } function Ho(t) { for (var e = t.map((function (t) { return { lrCoordinates: t, grouped: !1 } })), n = []; !Jo(e);)for (var r = 0; r < e.length; r++)if (!e[r].grouped) { var i = []; i.push(e[r].lrCoordinates), e[r].grouped = !0; for (var o = l([e[r].lrCoordinates]), s = r + 1; s < e.length; s++) { if (!e[s].grouped) Wo(l([e[s].lrCoordinates]), o) && (i.push(e[s].lrCoordinates), e[s].grouped = !0) } n.push(i) } return n } function Wo(t, e) { for (var n = En(t), r = 0; r < n.features.length; r++)if (!ye(n.features[r], e)) return !1; return !0 } function Jo(t) { for (var e = 0; e < t.length; e++)if (!1 === t[e].grouped) return !1; return !0 } function Zo(t, e, n) { if (!P(n = n || {})) throw new Error("options is invalid"); var r = n.pivot, i = n.mutate; if (!t) throw new Error("geojson is required"); if (null == e || isNaN(e)) throw new Error("angle is required"); return 0 === e || (r || (r = xn(t)), !1 !== i && void 0 !== i || (t = Ie(t)), z(t, (function (t) { var n = ki(r, t) + e, i = Tr(r, t), o = T(qi(r, i, n)); t[0] = o[0], t[1] = o[1] }))), t } function Ko(t, e, n) { if (!P(n = n || {})) throw new Error("options is invalid"); var r = n.origin, i = n.mutate; if (!t) throw new Error("geojson required"); if ("number" != typeof e || 0 === e) throw new Error("invalid factor"); var o = Array.isArray(r) || "object" == typeof r; return !0 !== i && (t = Ie(t)), "FeatureCollection" !== t.type || o ? Qo(t, e, r) : (X(t, (function (n, i) { t.features[i] = Qo(n, e, r) })), t) } function Qo(t, e, n) { var r = "Point" === q(t); return n = function (t, e) { null == e && (e = "centroid"); if (Array.isArray(e) || "object" == typeof e) return R(e); var n = t.bbox ? t.bbox : ot(t), r = n[0], i = n[1], o = n[2], s = n[3]; switch (e) { case "sw": case "southwest": case "westsouth": case "bottomleft": return a([r, i]); case "se": case "southeast": case "eastsouth": case "bottomright": return a([o, i]); case "nw": case "northwest": case "westnorth": case "topleft": return a([r, s]); case "ne": case "northeast": case "eastnorth": case "topright": return a([o, s]); case "center": return mn(t); case void 0: case null: case "centroid": return xn(t); default: throw new Error("invalid origin") } }(t, n), 1 === e || r || z(t, (function (t) { var r = Tr(n, t), i = ki(n, t), o = T(qi(n, r * e, i)); t[0] = o[0], t[1] = o[1], 3 === t.length && (t[2] *= e) })), t } function $o(t) { var e = t[0], n = t[1]; return [n[0] - e[0], n[1] - e[1]] } function ts(t, e) { return t[0] * e[1] - e[0] * t[1] } function es(t, e) { return !function (t, e) { return 0 === ts($o(t), $o(e)) }(t, e) && function (t, e) { var n, r, i = t[0], o = $o(t), s = e[0], a = $o(e), u = ts(o, a); return function (t, e) { return [t[0] + e[0], t[1] + e[1]] }(i, function (t, e) { return [t * e[0], t * e[1]] }(ts((r = i, [(n = s)[0] - r[0], n[1] - r[1]]), a) / u, o)) }(t, e) } function ns(t, e, n) { var r = [], i = E(e, n), o = T(t), s = []; return o.forEach((function (t, e) { if (e !== o.length - 1) { var n = (l = t, c = o[e + 1], h = i, p = Math.sqrt((l[0] - c[0]) * (l[0] - c[0]) + (l[1] - c[1]) * (l[1] - c[1])), f = l[0] + h * (c[1] - l[1]) / p, g = c[0] + h * (c[1] - l[1]) / p, d = l[1] + h * (l[0] - c[0]) / p, y = c[1] + h * (l[0] - c[0]) / p, [[f, d], [g, y]]); if (r.push(n), e > 0) { var a = r[e - 1], u = es(n, a); !1 !== u && (a[1] = u, n[0] = u), s.push(a[0]), e === o.length - 2 && (s.push(n[0]), s.push(n[1])) } 2 === o.length && (s.push(n[0]), s.push(n[1])) } var l, c, h, p, f, g, d, y })), h(s, t.properties) } function rs(t, e, n) { var r = e[0] - t[0], i = e[1] - t[1], o = n[0] - e[0]; return function (t) { return (t > 0) - (t < 0) || +t }(r * (n[1] - e[1]) - o * i) } function is(t, e) { return e.geometry.coordinates[0].every((function (e) { return ye(a(e), t) })) } Bo[1] = Bo[169] = Io, Bo[4] = Bo[166] = No, Bo[16] = Bo[154] = So, Bo[64] = Bo[106] = Co, Bo[168] = Bo[2] = Po, Bo[162] = Bo[8] = Lo, Bo[138] = Bo[32] = Mo, Bo[42] = Bo[128] = Oo, Bo[5] = Bo[165] = function (t) { return [[0, 0], [0, t.leftbottom], [1, t.rightbottom], [1, 0]] }, Bo[20] = Bo[150] = function (t) { return [[1, 0], [t.bottomright, 0], [t.topright, 1], [1, 1]] }, Bo[80] = Bo[90] = function (t) { return [[1, 1], [1, t.righttop], [0, t.lefttop], [0, 1]] }, Bo[65] = Bo[105] = function (t) { return [[t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]] }, Bo[160] = Bo[10] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [0, t.leftbottom], [0, t.lefttop]] }, Bo[130] = Bo[40] = function (t) { return [[t.topleft, 1], [t.topright, 1], [t.bottomright, 0], [t.bottomleft, 0]] }, Bo[85] = function () { return [[0, 0], [0, 1], [1, 1], [1, 0]] }, Bo[101] = Bo[69] = function (t) { return [[1, t.rightbottom], [1, 0], [0, 0], [0, 1], [t.topleft, 1]] }, Bo[149] = Bo[21] = function (t) { return [[t.topright, 1], [1, 1], [1, 0], [0, 0], [0, t.leftbottom]] }, Bo[86] = Bo[84] = function (t) { return [[1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [1, 1]] }, Bo[89] = Bo[81] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, 1]] }, Bo[96] = Bo[74] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, Bo[24] = Bo[146] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [t.topright, 1]] }, Bo[6] = Bo[164] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop]] }, Bo[129] = Bo[41] = function (t) { return [[t.topright, 1], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1]] }, Bo[66] = Bo[104] = function (t) { return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, Bo[144] = Bo[26] = function (t) { return [[1, 1], [1, t.righttop], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]] }, Bo[36] = Bo[134] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [t.topleft, 1], [t.topright, 1]] }, Bo[9] = Bo[161] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom]] }, Bo[37] = Bo[133] = function (t) { return [[1, t.rightbottom], [1, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]] }, Bo[148] = Bo[22] = function (t) { return [[1, 1], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]] }, Bo[82] = Bo[88] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1]] }, Bo[73] = Bo[97] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]] }, Bo[145] = Bo[25] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]] }, Bo[70] = Bo[100] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, Bo[34] = function (t) { return [Oo(t), Lo(t)] }, Bo[35] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]] }, Bo[136] = function (t) { return [Mo(t), Po(t)] }, Bo[153] = function (t) { return [So(t), Io(t)] }, Bo[102] = function (t) { return [No(t), Co(t)] }, Bo[155] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]] }, Bo[103] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, Bo[152] = function (t) { return [So(t), Po(t)] }, Bo[156] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]] }, Bo[137] = function (t) { return [Mo(t), Io(t)] }, Bo[139] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]] }, Bo[98] = function (t) { return [Lo(t), Co(t)] }, Bo[99] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, Bo[38] = function (t) { return [No(t), Oo(t)] }, Bo[39] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]] }; var os = function () { function t(e) { this.id = t.buildId(e), this.coordinates = e, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1 } return t.buildId = function (t) { return t.join(",") }, t.prototype.removeInnerEdge = function (t) { this.innerEdges = this.innerEdges.filter((function (e) { return e.from.id !== t.from.id })) }, t.prototype.removeOuterEdge = function (t) { this.outerEdges = this.outerEdges.filter((function (e) { return e.to.id !== t.to.id })) }, t.prototype.addOuterEdge = function (t) { this.outerEdges.push(t), this.outerEdgesSorted = !1 }, t.prototype.sortOuterEdges = function () { var t = this; this.outerEdgesSorted || (this.outerEdges.sort((function (e, n) { var r = e.to, i = n.to; if (r.coordinates[0] - t.coordinates[0] >= 0 && i.coordinates[0] - t.coordinates[0] < 0) return 1; if (r.coordinates[0] - t.coordinates[0] < 0 && i.coordinates[0] - t.coordinates[0] >= 0) return -1; if (r.coordinates[0] - t.coordinates[0] == 0 && i.coordinates[0] - t.coordinates[0] == 0) return r.coordinates[1] - t.coordinates[1] >= 0 || i.coordinates[1] - t.coordinates[1] >= 0 ? r.coordinates[1] - i.coordinates[1] : i.coordinates[1] - r.coordinates[1]; var o = rs(t.coordinates, r.coordinates, i.coordinates); return o < 0 ? 1 : o > 0 ? -1 : Math.pow(r.coordinates[0] - t.coordinates[0], 2) + Math.pow(r.coordinates[1] - t.coordinates[1], 2) - (Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2)) })), this.outerEdgesSorted = !0) }, t.prototype.getOuterEdges = function () { return this.sortOuterEdges(), this.outerEdges }, t.prototype.getOuterEdge = function (t) { return this.sortOuterEdges(), this.outerEdges[t] }, t.prototype.addInnerEdge = function (t) { this.innerEdges.push(t) }, t }(), ss = function () { function t(t, e) { this.from = t, this.to = e, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this) } return t.prototype.getSymetric = function () { return this.symetric || (this.symetric = new t(this.to, this.from), this.symetric.symetric = this), this.symetric }, t.prototype.deleteEdge = function () { this.from.removeOuterEdge(this), this.to.removeInnerEdge(this) }, t.prototype.isEqual = function (t) { return this.from.id === t.from.id && this.to.id === t.to.id }, t.prototype.toString = function () { return "Edge { " + this.from.id + " -> " + this.to.id + " }" }, t.prototype.toLineString = function () { return h([this.from.coordinates, this.to.coordinates]) }, t.prototype.compareTo = function (t) { return rs(t.from.coordinates, t.to.coordinates, this.to.coordinates) }, t }(), as = function () { function t() { this.edges = [], this.polygon = void 0, this.envelope = void 0 } return t.prototype.push = function (t) { this[this.edges.length] = t, this.edges.push(t), this.polygon = this.envelope = void 0 }, t.prototype.get = function (t) { return this.edges[t] }, Object.defineProperty(t.prototype, "length", { get: function () { return this.edges.length }, enumerable: !0, configurable: !0 }), t.prototype.forEach = function (t) { this.edges.forEach(t) }, t.prototype.map = function (t) { return this.edges.map(t) }, t.prototype.some = function (t) { return this.edges.some(t) }, t.prototype.isValid = function () { return !0 }, t.prototype.isHole = function () { var t = this, e = this.edges.reduce((function (e, n, r) { return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e }), 0), n = (0 === e ? this.length : e) - 1, r = (e + 1) % this.length, i = rs(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[r].from.coordinates); return 0 === i ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : i > 0 }, t.prototype.toMultiPoint = function () { return d(this.edges.map((function (t) { return t.from.coordinates }))) }, t.prototype.toPolygon = function () { if (this.polygon) return this.polygon; var t = this.edges.map((function (t) { return t.from.coordinates })); return t.push(this.edges[0].from.coordinates), this.polygon = l([t]) }, t.prototype.getEnvelope = function () { return this.envelope ? this.envelope : this.envelope = gn(this.toPolygon()) }, t.findEdgeRingContaining = function (t, e) { var n, r, i = t.getEnvelope(); return e.forEach((function (e) { var o, s, u, l, c, h, p = e.getEnvelope(); if ((r && (n = r.getEnvelope()), s = i, u = (o = p).geometry.coordinates.map((function (t) { return t[0] })), l = o.geometry.coordinates.map((function (t) { return t[1] })), c = s.geometry.coordinates.map((function (t) { return t[0] })), h = s.geometry.coordinates.map((function (t) { return t[1] })), Math.max(null, u) !== Math.max(null, c) || Math.max(null, l) !== Math.max(null, h) || Math.min(null, u) !== Math.min(null, c) || Math.min(null, l) !== Math.min(null, h)) && is(p, i)) { var f = t.map((function (t) { return t.from.coordinates })).find((function (t) { return !e.some((function (e) { return n = t, r = e.from.coordinates, n[0] === r[0] && n[1] === r[1]; var n, r })) })); f && e.inside(a(f)) && (r && !is(n, p) || (r = e)) } })), r }, t.prototype.inside = function (t) { return ye(t, this.toPolygon()) }, t }(); var us = function () { function t() { this.edges = [], this.nodes = {} } return t.fromGeoJson = function (e) { !function (t) { if (!t) throw new Error("No geojson passed"); if ("FeatureCollection" !== t.type && "GeometryCollection" !== t.type && "MultiLineString" !== t.type && "LineString" !== t.type && "Feature" !== t.type) throw new Error("Invalid input type '" + t.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature") }(e); var n = new t; return Z(e, (function (t) { F(t, "LineString", "Graph::fromGeoJson"), j(t, (function (t, e) { if (t) { var r = n.getNode(t), i = n.getNode(e); n.addEdge(r, i) } return e })) })), n }, t.prototype.getNode = function (t) { var e = os.buildId(t), n = this.nodes[e]; return n || (n = this.nodes[e] = new os(t)), n }, t.prototype.addEdge = function (t, e) { var n = new ss(t, e), r = n.getSymetric(); this.edges.push(n), this.edges.push(r) }, t.prototype.deleteDangles = function () { var t = this; Object.keys(this.nodes).map((function (e) { return t.nodes[e] })).forEach((function (e) { return t._removeIfDangle(e) })) }, t.prototype._removeIfDangle = function (t) { var e = this; if (t.innerEdges.length <= 1) { var n = t.getOuterEdges().map((function (t) { return t.to })); this.removeNode(t), n.forEach((function (t) { return e._removeIfDangle(t) })) } }, t.prototype.deleteCutEdges = function () { var t = this; this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach((function (e) { e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e)) })) }, t.prototype._computeNextCWEdges = function (t) { var e = this; void 0 === t ? Object.keys(this.nodes).forEach((function (t) { return e._computeNextCWEdges(e.nodes[t]) })) : t.getOuterEdges().forEach((function (e, n) { t.getOuterEdge((0 === n ? t.getOuterEdges().length : n) - 1).symetric.next = e })) }, t.prototype._computeNextCCWEdges = function (t, e) { for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) { var s = i[o], a = s.symetric, u = void 0, l = void 0; s.label === e && (u = s), a.label === e && (l = a), u && l && (l && (r = l), u && (r && (r.next = u, r = void 0), n || (n = u))) } r && (r.next = n) }, t.prototype._findLabeledEdgeRings = function () { var t = [], e = 0; return this.edges.forEach((function (n) { if (!(n.label >= 0)) { t.push(n); var r = n; do { r.label = e, r = r.next } while (!n.isEqual(r)); e++ } })), t }, t.prototype.getEdgeRings = function () { var t = this; this._computeNextCWEdges(), this.edges.forEach((function (t) { t.label = void 0 })), this._findLabeledEdgeRings().forEach((function (e) { t._findIntersectionNodes(e).forEach((function (n) { t._computeNextCCWEdges(n, e.label) })) })); var e = []; return this.edges.forEach((function (n) { n.ring || e.push(t._findEdgeRing(n)) })), e }, t.prototype._findIntersectionNodes = function (t) { var e = [], n = t, r = function () { var r = 0; n.from.getOuterEdges().forEach((function (e) { e.label === t.label && ++r })), r > 1 && e.push(n.from), n = n.next }; do { r() } while (!t.isEqual(n)); return e }, t.prototype._findEdgeRing = function (t) { var e = t, n = new as; do { n.push(e), e.ring = n, e = e.next } while (!t.isEqual(e)); return n }, t.prototype.removeNode = function (t) { var e = this; t.getOuterEdges().forEach((function (t) { return e.removeEdge(t) })), t.innerEdges.forEach((function (t) { return e.removeEdge(t) })), delete this.nodes[t.id] }, t.prototype.removeEdge = function (t) { this.edges = this.edges.filter((function (e) { return !e.isEqual(t) })), t.deleteEdge() }, t }(); function ls(t, e) { var n = !0; return Z(t, (function (t) { Z(e, (function (e) { if (!1 === n) return !1; n = function (t, e) { switch (t.type) { case "Point": switch (e.type) { case "Point": return n = t.coordinates, r = e.coordinates, !(n[0] === r[0] && n[1] === r[1]); case "LineString": return !cs(e, t); case "Polygon": return !ye(t, e) }break; case "LineString": switch (e.type) { case "Point": return !cs(t, e); case "LineString": return !function (t, e) { if (Mr(t, e).features.length > 0) return !0; return !1 }(t, e); case "Polygon": return !hs(e, t) }break; case "Polygon": switch (e.type) { case "Point": return !ye(e, t); case "LineString": return !hs(t, e); case "Polygon": return !function (t, e) { for (var n = 0, r = t.coordinates[0]; n < r.length; n++) { if (ye(r[n], e)) return !0 } for (var i = 0, o = e.coordinates[0]; i < o.length; i++) { if (ye(o[i], t)) return !0 } if (Mr(Ei(t), Ei(e)).features.length > 0) return !0; return !1 }(e, t) } }var n, r; return !1 }(t.geometry, e.geometry) })) })), n } function cs(t, e) { for (var n = 0; n < t.coordinates.length - 1; n++)if (ps(t.coordinates[n], t.coordinates[n + 1], e.coordinates)) return !0; return !1 } function hs(t, e) { for (var n = 0, r = e.coordinates; n < r.length; n++) { if (ye(r[n], t)) return !0 } return Mr(e, Ei(t)).features.length > 0 } function ps(t, e, n) { var r = n[0] - t[0], i = n[1] - t[1], o = e[0] - t[0], s = e[1] - t[1]; return 0 == r * s - i * o && (Math.abs(o) >= Math.abs(s) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1]) } function fs(t, e) { return !(t[0] > e[0]) && (!(t[2] < e[2]) && (!(t[1] > e[1]) && !(t[3] < e[3]))) } function gs(t, e) { return t[0] === e[0] && t[1] === e[1] } function ds(t, e) { return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2] } function ys(t, e) { for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) { for (var s = 0; s < e.coordinates.length - 1; s++) { var a = !0; 0 !== s && s !== e.coordinates.length - 2 || (a = !1), ms(e.coordinates[s], e.coordinates[s + 1], t.coordinates[o], a) ? n = !0 : r = !0 } o++ } return n && r } function vs(t, e) { return Mr(t, bi(e)).features.length > 0 } function _s(t, e) { for (var n = !1, r = !1, i = t.coordinates[0].length, o = 0; o < i && n && r;)ye(a(t.coordinates[0][o]), e) ? n = !0 : r = !0, o++; return r && r } function ms(t, e, n, r) { var i = n[0] - t[0], o = n[1] - t[1], s = e[0] - t[0], a = e[1] - t[1]; return 0 == i * a - o * s && (r ? Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : a > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : a > 0 ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1]) } var xs = function (t) { this.precision = t && t.precision ? t.precision : 17, this.direction = !(!t || !t.direction) && t.direction, this.pseudoNode = !(!t || !t.pseudoNode) && t.pseudoNode, this.objectComparator = t && t.objectComparator ? t.objectComparator : ws }; function Es(t) { return t.coordinates.map((function (e) { return { type: t.type.replace("Multi", ""), coordinates: e } })) } function bs(t, e) { return t.hasOwnProperty("coordinates") ? t.coordinates.length === e.coordinates.length : t.length === e.length } function ws(t, e) { return Ti(t, e, { strict: !0 }) } xs.prototype.compare = function (t, e) { if (t.type !== e.type || !bs(t, e)) return !1; switch (t.type) { case "Point": return this.compareCoord(t.coordinates, e.coordinates); case "LineString": return this.compareLine(t.coordinates, e.coordinates, 0, !1); case "Polygon": return this.comparePolygon(t, e); case "Feature": return this.compareFeature(t, e); default: if (0 === t.type.indexOf("Multi")) { var n = this, r = Es(t), i = Es(e); return r.every((function (t) { return this.some((function (e) { return n.compare(t, e) })) }), i) } }return !1 }, xs.prototype.compareCoord = function (t, e) { if (t.length !== e.length) return !1; for (var n = 0; n < t.length; n++)if (t[n].toFixed(this.precision) !== e[n].toFixed(this.precision)) return !1; return !0 }, xs.prototype.compareLine = function (t, e, n, r) { if (!bs(t, e)) return !1; var i = this.pseudoNode ? t : this.removePseudo(t), o = this.pseudoNode ? e : this.removePseudo(e); if (!r || this.compareCoord(i[0], o[0]) || (o = this.fixStartIndex(o, i))) { var s = this.compareCoord(i[n], o[n]); return this.direction || s ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o) } }, xs.prototype.fixStartIndex = function (t, e) { for (var n, r = -1, i = 0; i < t.length; i++)if (this.compareCoord(t[i], e[0])) { r = i; break } return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n }, xs.prototype.comparePath = function (t, e) { var n = this; return t.every((function (t, e) { return n.compareCoord(t, this[e]) }), e) }, xs.prototype.comparePolygon = function (t, e) { if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) { var n = t.coordinates.slice(1, t.coordinates.length), r = e.coordinates.slice(1, e.coordinates.length), i = this; return n.every((function (t) { return this.some((function (e) { return i.compareLine(t, e, 1, !0) })) }), r) } return !1 }, xs.prototype.compareFeature = function (t, e) { return !(t.id !== e.id || !this.objectComparator(t.properties, e.properties) || !this.compareBBox(t, e)) && this.compare(t.geometry, e.geometry) }, xs.prototype.compareBBox = function (t, e) { return !!(!t.bbox && !e.bbox || t.bbox && e.bbox && this.compareCoord(t.bbox, e.bbox)) }, xs.prototype.removePseudo = function (t) { return t }; var Is = xs; function Ns(t, e) { var n = G(t), r = G(e), i = n.type, o = r.type; if ("MultiPoint" === i && "MultiPoint" !== o || ("LineString" === i || "MultiLineString" === i) && "LineString" !== o && "MultiLineString" !== o || ("Polygon" === i || "MultiPolygon" === i) && "Polygon" !== o && "MultiPolygon" !== o) throw new Error("features must be of the same type"); if ("Point" === i) throw new Error("Point geometry not supported"); if (new Is({ precision: 6 }).compare(t, e)) return !1; var s = 0; switch (i) { case "MultiPoint": for (var a = 0; a < n.coordinates.length; a++)for (var u = 0; u < r.coordinates.length; u++) { var l = n.coordinates[a], c = r.coordinates[u]; if (l[0] === c[0] && l[1] === c[1]) return !0 } return !1; case "LineString": case "MultiLineString": Q(t, (function (t) { Q(e, (function (e) { Ai(t, e).features.length && s++ })) })); break; case "Polygon": case "MultiPolygon": Q(t, (function (t) { Q(e, (function (e) { Mr(t, e).features.length && s++ })) })) }return s > 0 } function Ss(t, e) { var n = !1; return Z(t, (function (t) { Z(e, (function (e) { if (!0 === n) return !0; n = !ls(t.geometry, e.geometry) })) })), n } var Cs = Bt((function (t) { function e(t, e, n, r) { this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(t, e, n, r) } e.prototype.run = function (t, e, n, r) { this._init(t, e, n, r); for (var i = 0; i < this._datasetLength; i++)if (1 !== this._visited[i]) { this._visited[i] = 1; var o = this._regionQuery(i); if (o.length < this.minPts) this.noise.push(i); else { var s = this.clusters.length; this.clusters.push([]), this._addToCluster(i, s), this._expandCluster(s, o) } } return this.clusters }, e.prototype._init = function (t, e, n, r) { if (t) { if (!(t instanceof Array)) throw Error("Dataset must be of type array, " + typeof t + " given"); this.dataset = t, this.clusters = [], this.noise = [], this._datasetLength = t.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength) } e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r) }, e.prototype._expandCluster = function (t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; if (1 !== this._visited[r]) { this._visited[r] = 1; var i = this._regionQuery(r); i.length >= this.minPts && (e = this._mergeArrays(e, i)) } 1 !== this._assigned[r] && this._addToCluster(r, t) } }, e.prototype._addToCluster = function (t, e) { this.clusters[e].push(t), this._assigned[t] = 1 }, e.prototype._regionQuery = function (t) { for (var e = [], n = 0; n < this._datasetLength; n++) { this.distance(this.dataset[t], this.dataset[n]) < this.epsilon && e.push(n) } return e }, e.prototype._mergeArrays = function (t, e) { for (var n = e.length, r = 0; r < n; r++) { var i = e[r]; t.indexOf(i) < 0 && t.push(i) } return t }, e.prototype._euclideanDistance = function (t, e) { for (var n = 0, r = Math.min(t.length, e.length); r--;)n += (t[r] - e[r]) * (t[r] - e[r]); return Math.sqrt(n) }, t.exports && (t.exports = e) })), Ps = Bt((function (t) { function e(t, e, n) { this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(t, e, n) } e.prototype.init = function (t, e, n) { this.assignments = [], this.centroids = [], void 0 !== t && (this.dataset = t), void 0 !== e && (this.k = e), void 0 !== n && (this.distance = n) }, e.prototype.run = function (t, e) { this.init(t, e); for (var n = this.dataset.length, r = 0; r < this.k; r++)this.centroids[r] = this.randomCentroid(); for (var i = !0; i;) { i = this.assign(); for (var o = 0; o < this.k; o++) { for (var s = new Array(c), a = 0, u = 0; u < c; u++)s[u] = 0; for (var l = 0; l < n; l++) { var c = this.dataset[l].length; if (o === this.assignments[l]) { for (u = 0; u < c; u++)s[u] += this.dataset[l][u]; a++ } } if (a > 0) { for (u = 0; u < c; u++)s[u] /= a; this.centroids[o] = s } else this.centroids[o] = this.randomCentroid(), i = !0 } } return this.getClusters() }, e.prototype.randomCentroid = function () { var t, e, n = this.dataset.length - 1; do { e = Math.round(Math.random() * n), t = this.dataset[e] } while (this.centroids.indexOf(t) >= 0); return t }, e.prototype.assign = function () { for (var t, e = !1, n = this.dataset.length, r = 0; r < n; r++)(t = this.argmin(this.dataset[r], this.centroids, this.distance)) != this.assignments[r] && (this.assignments[r] = t, e = !0); return e }, e.prototype.getClusters = function () { for (var t, e = new Array(this.k), n = 0; n < this.assignments.length; n++)void 0 === e[t = this.assignments[n]] && (e[t] = []), e[t].push(n); return e }, e.prototype.argmin = function (t, e, n) { for (var r, i = Number.MAX_VALUE, o = 0, s = e.length, a = 0; a < s; a++)(r = n(t, e[a])) < i && (i = r, o = a); return o }, e.prototype.distance = function (t, e) { for (var n = 0, r = Math.min(t.length, e.length); r--;) { var i = t[r] - e[r]; n += i * i } return Math.sqrt(n) }, t.exports && (t.exports = e) })), Ls = Bt((function (t) { function e(t, e, n) { this._queue = [], this._priorities = [], this._sorting = "desc", this._init(t, e, n) } e.prototype.insert = function (t, e) { for (var n = this._queue.length, r = n; r--;) { var i = this._priorities[r]; "desc" === this._sorting ? e > i && (n = r) : e < i && (n = r) } this._insertAt(t, e, n) }, e.prototype.remove = function (t) { for (var e = this._queue.length; e--;) { if (t === this._queue[e]) { this._queue.splice(e, 1), this._priorities.splice(e, 1); break } } }, e.prototype.forEach = function (t) { this._queue.forEach(t) }, e.prototype.getElements = function () { return this._queue }, e.prototype.getElementPriority = function (t) { return this._priorities[t] }, e.prototype.getPriorities = function () { return this._priorities }, e.prototype.getElementsWithPriorities = function () { for (var t = [], e = 0, n = this._queue.length; e < n; e++)t.push([this._queue[e], this._priorities[e]]); return t }, e.prototype._init = function (t, e, n) { if (t && e) { if (this._queue = [], this._priorities = [], t.length !== e.length) throw new Error("Arrays must have the same length"); for (var r = 0; r < t.length; r++)this.insert(t[r], e[r]) } n && (this._sorting = n) }, e.prototype._insertAt = function (t, e, n) { this._queue.length === n ? (this._queue.push(t), this._priorities.push(e)) : (this._queue.splice(n, 0, t), this._priorities.splice(n, 0, e)) }, t.exports && (t.exports = e) })), Ms = Bt((function (t) { if (t.exports) var e = Ls; function n(t, e, n, r) { this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(t, e, n, r) } n.prototype.run = function (t, n, r, i) { this._init(t, n, r, i); for (var o = 0, s = this.dataset.length; o < s; o++)if (1 !== this._processed[o]) { this._processed[o] = 1, this.clusters.push([o]); var a = this.clusters.length - 1; this._orderedList.push(o); var u = new e(null, null, "asc"), l = this._regionQuery(o); void 0 !== this._distanceToCore(o) && (this._updateQueue(o, l, u), this._expandCluster(a, u)) } return this.clusters }, n.prototype.getReachabilityPlot = function () { for (var t = [], e = 0, n = this._orderedList.length; e < n; e++) { var r = this._orderedList[e], i = this._reachability[r]; t.push([r, i]) } return t }, n.prototype._init = function (t, e, n, r) { if (t) { if (!(t instanceof Array)) throw Error("Dataset must be of type array, " + typeof t + " given"); this.dataset = t, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = [] } e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r) }, n.prototype._updateQueue = function (t, e, n) { var r = this; this._coreDistance = this._distanceToCore(t), e.forEach((function (e) { if (void 0 === r._processed[e]) { var i = r.distance(r.dataset[t], r.dataset[e]), o = Math.max(r._coreDistance, i); void 0 === r._reachability[e] ? (r._reachability[e] = o, n.insert(e, o)) : o < r._reachability[e] && (r._reachability[e] = o, n.remove(e), n.insert(e, o)) } })) }, n.prototype._expandCluster = function (t, e) { for (var n = e.getElements(), r = 0, i = n.length; r < i; r++) { var o = n[r]; if (void 0 === this._processed[o]) { var s = this._regionQuery(o); this._processed[o] = 1, this.clusters[t].push(o), this._orderedList.push(o), void 0 !== this._distanceToCore(o) && (this._updateQueue(o, s, e), this._expandCluster(t, e)) } } }, n.prototype._distanceToCore = function (t) { for (var e = this.epsilon, n = 0; n < e; n++) { if (this._regionQuery(t, n).length >= this.minPts) return n } }, n.prototype._regionQuery = function (t, e) { e = e || this.epsilon; for (var n = [], r = 0, i = this.dataset.length; r < i; r++)this.distance(this.dataset[t], this.dataset[r]) < e && n.push(r); return n }, n.prototype._euclideanDistance = function (t, e) { for (var n = 0, r = Math.min(t.length, e.length); r--;)n += (t[r] - e[r]) * (t[r] - e[r]); return Math.sqrt(n) }, t.exports && (t.exports = n) })), Os = Bt((function (t) { t.exports && (t.exports = { DBSCAN: Cs, KMEANS: Ps, OPTICS: Ms, PriorityQueue: Ls }) })); var Rs = function (t, e, n) { for (var r = t.length, i = 0, o = 0; o < r; o++) { var s = (t[o] || 0) - (e[o] || 0); i += s * s } return n ? Math.sqrt(i) : i }, Ts = Rs, As = function (t, e, n) { var r = Math.abs(t - e); return n ? r : r * r }, Ds = Rs, Fs = function (t, e) { for (var n = {}, r = [], i = e << 2, o = t.length, s = t[0].length > 0; r.length < e && i-- > 0;) { var a = t[Math.floor(Math.random() * o)], u = s ? a.join("_") : "" + a; n[u] || (n[u] = !0, r.push(a)) } if (r.length < e) throw new Error("Error initializating clusters"); return r }, ks = function (t, e) { var n = t[0].length ? Ts : As, r = [], i = t.length, o = t[0].length > 0, s = t[Math.floor(Math.random() * i)]; o && s.join("_"); for (r.push(s); r.length < e;) { for (var a = [], u = r.length, l = 0, c = [], h = 0; h < i; h++) { for (var p = 1 / 0, f = 0; f < u; f++) { var g = n(t[h], r[f]); g <= p && (p = g) } a[h] = p } for (var d = 0; d < i; d++)l += a[d]; for (var y = 0; y < i; y++)c[y] = { i: y, v: t[y], pr: a[y] / l, cs: 0 }; c.sort((function (t, e) { return t.pr - e.pr })), c[0].cs = c[0].pr; for (var v = 1; v < i; v++)c[v].cs = c[v - 1].cs + c[v].pr; for (var _ = Math.random(), m = 0; m < i - 1 && c[m++].cs < _;); r.push(c[m - 1].v) } return r }; function Gs(t, e, n) { n = n || []; for (var r = 0; r < t; r++)n[r] = e; return n } var qs = function (t, e, n, r) { var i = [], o = [], s = [], a = [], u = !1, l = r || 1e4, c = t.length, h = t[0].length, p = h > 0, f = []; if (n) i = "kmrand" == n ? Fs(t, e) : "kmpp" == n ? ks(t, e) : n; else for (var g = {}; i.length < e;) { var d = Math.floor(Math.random() * c); g[d] || (g[d] = !0, i.push(t[d])) } do { Gs(e, 0, f); for (var y = 0; y < c; y++) { for (var v = 1 / 0, _ = 0, m = 0; m < e; m++) { (a = p ? Ds(t[y], i[m]) : Math.abs(t[y] - i[m])) <= v && (v = a, _ = m) } s[y] = _, f[_]++ } for (var x = [], E = (o = [], 0); E < e; E++)x[E] = p ? Gs(h, 0, x[E]) : 0, o[E] = i[E]; if (p) { for (var b = 0; b < e; b++)i[b] = []; for (var w = 0; w < c; w++)for (var I = x[s[w]], N = t[w], S = 0; S < h; S++)I[S] += N[S]; u = !0; for (var C = 0; C < e; C++) { for (var P = i[C], L = x[C], M = o[C], O = f[C], R = 0; R < h; R++)P[R] = L[R] / O || 0; if (u) for (var T = 0; T < h; T++)if (M[T] != P[T]) { u = !1; break } } } else { for (var A = 0; A < c; A++) { x[s[A]] += t[A] } for (var D = 0; D < e; D++)i[D] = x[D] / f[D] || 0; u = !0; for (var F = 0; F < e; F++)if (o[F] != i[F]) { u = !1; break } } u = u || --l <= 0 } while (!u); return { it: 1e4 - l, k: e, idxs: s, centroids: i } }; function Bs(t, e) { return b(ki(t[0], t[1])) === b(ki(e[0], e[1])) } function zs(t, e) { if (t.geometry && t.geometry.type) return t.geometry.type; if (t.type) return t.type; throw new Error("Invalid GeoJSON object for " + e) } function js(t) { for (var e = t, n = []; e.parent;)n.unshift(e), e = e.parent; return n } var Us = { search: function (t, e, n, r) { t.cleanDirty(); var i = (r = r || {}).heuristic || Us.heuristics.manhattan, o = r.closest || !1, s = new Ys((function (t) { return t.f })), a = e; for (e.h = i(e, n), s.push(e); s.size() > 0;) { var u = s.pop(); if (u === n) return js(u); u.closed = !0; for (var l = t.neighbors(u), c = 0, h = l.length; c < h; ++c) { var p = l[c]; if (!p.closed && !p.isWall()) { var f = u.g + p.getCost(u), g = p.visited; (!g || f < p.g) && (p.visited = !0, p.parent = u, p.h = p.h || i(p, n), p.g = f, p.f = p.g + p.h, t.markDirty(p), o && (p.h < a.h || p.h === a.h && p.g < a.g) && (a = p), g ? s.rescoreElement(p) : s.push(p)) } } } return o ? js(a) : [] }, heuristics: { manhattan: function (t, e) { return Math.abs(e.x - t.x) + Math.abs(e.y - t.y) }, diagonal: function (t, e) { var n = Math.sqrt(2), r = Math.abs(e.x - t.x), i = Math.abs(e.y - t.y); return 1 * (r + i) + (n - 2) * Math.min(r, i) } }, cleanNode: function (t) { t.f = 0, t.g = 0, t.h = 0, t.visited = !1, t.closed = !1, t.parent = null } }; function Vs(t, e) { e = e || {}, this.nodes = [], this.diagonal = !!e.diagonal, this.grid = []; for (var n = 0; n < t.length; n++) { this.grid[n] = []; for (var r = 0, i = t[n]; r < i.length; r++) { var o = new Xs(n, r, i[r]); this.grid[n][r] = o, this.nodes.push(o) } } this.init() } function Xs(t, e, n) { this.x = t, this.y = e, this.weight = n } function Ys(t) { this.content = [], this.scoreFunction = t } function Hs(t, e) { for (var n = 0; n < e.features.length; n++)if (ye(t, e.features[n])) return !0; return !1 } function Ws(t) { return function () { return t } } function Js(t) { return t[0] } function Zs(t) { return t[1] } function Ks() { this._ = null } function Qs(t) { t.U = t.C = t.L = t.R = t.P = t.N = null } function $s(t, e) { var n = e, r = e.R, i = n.U; i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n } function ta(t, e) { var n = e, r = e.L, i = n.U; i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n } function ea(t) { for (; t.L;)t = t.L; return t } function na(t, e, n, r) { var i = [null, null], o = Sa.push(i) - 1; return i.left = t, i.right = e, n && ia(i, t, e, n), r && ia(i, e, t, r), Ia[t.index].halfedges.push(o), Ia[e.index].halfedges.push(o), i } function ra(t, e, n) { var r = [e, n]; return r.left = t, r } function ia(t, e, n, r) { t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n) } function oa(t, e, n, r, i) { var o, s = t[0], a = t[1], u = s[0], l = s[1], c = 0, h = 1, p = a[0] - u, f = a[1] - l; if (o = e - u, p || !(o > 0)) { if (o /= p, p < 0) { if (o < c) return; o < h && (h = o) } else if (p > 0) { if (o > h) return; o > c && (c = o) } if (o = r - u, p || !(o < 0)) { if (o /= p, p < 0) { if (o > h) return; o > c && (c = o) } else if (p > 0) { if (o < c) return; o < h && (h = o) } if (o = n - l, f || !(o > 0)) { if (o /= f, f < 0) { if (o < c) return; o < h && (h = o) } else if (f > 0) { if (o > h) return; o > c && (c = o) } if (o = i - l, f || !(o < 0)) { if (o /= f, f < 0) { if (o > h) return; o > c && (c = o) } else if (f > 0) { if (o < c) return; o < h && (h = o) } return !(c > 0 || h < 1) || (c > 0 && (t[0] = [u + c * p, l + c * f]), h < 1 && (t[1] = [u + h * p, l + h * f]), !0) } } } } } function sa(t, e, n, r, i) { var o = t[1]; if (o) return !0; var s, a, u = t[0], l = t.left, c = t.right, h = l[0], p = l[1], f = c[0], g = c[1], d = (h + f) / 2, y = (p + g) / 2; if (g === p) { if (d < e || d >= r) return; if (h > f) { if (u) { if (u[1] >= i) return } else u = [d, n]; o = [d, i] } else { if (u) { if (u[1] < n) return } else u = [d, i]; o = [d, n] } } else if (a = y - (s = (h - f) / (g - p)) * d, s < -1 || s > 1) if (h > f) { if (u) { if (u[1] >= i) return } else u = [(n - a) / s, n]; o = [(i - a) / s, i] } else { if (u) { if (u[1] < n) return } else u = [(i - a) / s, i]; o = [(n - a) / s, n] } else if (p < g) { if (u) { if (u[0] >= r) return } else u = [e, s * e + a]; o = [r, s * r + a] } else { if (u) { if (u[0] < e) return } else u = [r, s * r + a]; o = [e, s * e + a] } return t[0] = u, t[1] = o, !0 } function aa(t, e) { var n = t.site, r = e.left, i = e.right; return n === i && (i = r, r = n), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (n === r ? (r = e[1], i = e[0]) : (r = e[0], i = e[1]), Math.atan2(r[0] - i[0], i[1] - r[1])) } function ua(t, e) { return e[+(e.left !== t.site)] } function la(t, e) { return e[+(e.left === t.site)] } Vs.prototype.init = function () { this.dirtyNodes = []; for (var t = 0; t < this.nodes.length; t++)Us.cleanNode(this.nodes[t]) }, Vs.prototype.cleanDirty = function () { for (var t = 0; t < this.dirtyNodes.length; t++)Us.cleanNode(this.dirtyNodes[t]); this.dirtyNodes = [] }, Vs.prototype.markDirty = function (t) { this.dirtyNodes.push(t) }, Vs.prototype.neighbors = function (t) { var e = [], n = t.x, r = t.y, i = this.grid; return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e }, Vs.prototype.toString = function () { for (var t, e, n, r, i = [], o = this.grid, s = 0, a = o.length; s < a; s++) { for (t = [], n = 0, r = (e = o[s]).length; n < r; n++)t.push(e[n].weight); i.push(t.join(" ")) } return i.join("\n") }, Xs.prototype.toString = function () { return "[" + this.x + " " + this.y + "]" }, Xs.prototype.getCost = function (t) { return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight }, Xs.prototype.isWall = function () { return 0 === this.weight }, Ys.prototype = { push: function (t) { this.content.push(t), this.sinkDown(this.content.length - 1) }, pop: function () { var t = this.content[0], e = this.content.pop(); return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t }, remove: function (t) { var e = this.content.indexOf(t), n = this.content.pop(); e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e)) }, size: function () { return this.content.length }, rescoreElement: function (t) { this.sinkDown(this.content.indexOf(t)) }, sinkDown: function (t) { for (var e = this.content[t]; t > 0;) { var n = (t + 1 >> 1) - 1, r = this.content[n]; if (!(this.scoreFunction(e) < this.scoreFunction(r))) break; this.content[n] = e, this.content[t] = r, t = n } }, bubbleUp: function (t) { for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n); ;) { var i, o = t + 1 << 1, s = o - 1, a = null; if (s < e) { var u = this.content[s]; (i = this.scoreFunction(u)) < r && (a = s) } if (o < e) { var l = this.content[o]; this.scoreFunction(l) < (null === a ? r : i) && (a = o) } if (null === a) break; this.content[t] = this.content[a], this.content[a] = n, t = a } } }, Ks.prototype = { constructor: Ks, insert: function (t, e) { var n, r, i; if (t) { if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) { for (t = t.R; t.L;)t = t.L; t.L = e } else t.R = e; n = t } else this._ ? (t = ea(this._), e.P = null, e.N = t, t.P = t.L = e, n = t) : (e.P = e.N = null, this._ = e, n = null); for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;)n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && ($s(this, n), n = (t = n).U), n.C = !1, r.C = !0, ta(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (ta(this, n), n = (t = n).U), n.C = !1, r.C = !0, $s(this, r)), n = t.U; this._.C = !1 }, remove: function (t) { t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null; var e, n, r, i = t.U, o = t.L, s = t.R; if (n = o ? s ? ea(s) : o : s, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && s ? (r = n.C, n.C = t.C, n.L = o, o.U = n, n !== s ? (i = n.U, n.U = t.U, t = n.R, i.L = t, n.R = s, s.U = n) : (n.U = i, i = n, t = n.R)) : (r = t.C, t = n), t && (t.U = i), !r) if (t && t.C) t.C = !1; else { do { if (t === this._) break; if (t === i.L) { if ((e = i.R).C && (e.C = !1, i.C = !0, $s(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) { e.R && e.R.C || (e.L.C = !1, e.C = !0, ta(this, e), e = i.R), e.C = i.C, i.C = e.R.C = !1, $s(this, i), t = this._; break } } else if ((e = i.L).C && (e.C = !1, i.C = !0, ta(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) { e.L && e.L.C || (e.R.C = !1, e.C = !0, $s(this, e), e = i.L), e.C = i.C, i.C = e.L.C = !1, ta(this, i), t = this._; break } e.C = !0, t = i, i = i.U } while (!t.C); t && (t.C = !1) } } }; var ca, ha = []; function pa() { Qs(this), this.x = this.y = this.arc = this.site = this.cy = null } function fa(t) { var e = t.P, n = t.N; if (e && n) { var r = e.site, i = t.site, o = n.site; if (r !== o) { var s = i[0], a = i[1], u = r[0] - s, l = r[1] - a, c = o[0] - s, h = o[1] - a, p = 2 * (u * h - l * c); if (!(p >= -Pa)) { var f = u * u + l * l, g = c * c + h * h, d = (h * f - l * g) / p, y = (u * g - c * f) / p, v = ha.pop() || new pa; v.arc = t, v.site = i, v.x = d + s, v.y = (v.cy = y + a) + Math.sqrt(d * d + y * y), t.circle = v; for (var _ = null, m = Na._; m;)if (v.y < m.y || v.y === m.y && v.x <= m.x) { if (!m.L) { _ = m.P; break } m = m.L } else { if (!m.R) { _ = m; break } m = m.R } Na.insert(_, v), _ || (ca = v) } } } } function ga(t) { var e = t.circle; e && (e.P || (ca = e.N), Na.remove(e), ha.push(e), Qs(e), t.circle = null) } var da = []; function ya() { Qs(this), this.edge = this.site = this.circle = null } function va(t) { var e = da.pop() || new ya; return e.site = t, e } function _a(t) { ga(t), wa.remove(t), da.push(t), Qs(t) } function ma(t) { var e = t.circle, n = e.x, r = e.cy, i = [n, r], o = t.P, s = t.N, a = [t]; _a(t); for (var u = o; u.circle && Math.abs(n - u.circle.x) < Ca && Math.abs(r - u.circle.cy) < Ca;)o = u.P, a.unshift(u), _a(u), u = o; a.unshift(u), ga(u); for (var l = s; l.circle && Math.abs(n - l.circle.x) < Ca && Math.abs(r - l.circle.cy) < Ca;)s = l.N, a.push(l), _a(l), l = s; a.push(l), ga(l); var c, h = a.length; for (c = 1; c < h; ++c)l = a[c], u = a[c - 1], ia(l.edge, u.site, l.site, i); u = a[0], (l = a[h - 1]).edge = na(u.site, l.site, null, i), fa(u), fa(l) } function xa(t) { for (var e, n, r, i, o = t[0], s = t[1], a = wa._; a;)if ((r = Ea(a, s) - o) > Ca) a = a.L; else { if (!((i = o - ba(a, s)) > Ca)) { r > -Ca ? (e = a.P, n = a) : i > -Ca ? (e = a, n = a.N) : e = n = a; break } if (!a.R) { e = a; break } a = a.R } !function (t) { Ia[t.index] = { site: t, halfedges: [] } }(t); var u = va(t); if (wa.insert(e, u), e || n) { if (e === n) return ga(e), n = va(e.site), wa.insert(u, n), u.edge = n.edge = na(e.site, u.site), fa(e), void fa(n); if (n) { ga(e), ga(n); var l = e.site, c = l[0], h = l[1], p = t[0] - c, f = t[1] - h, g = n.site, d = g[0] - c, y = g[1] - h, v = 2 * (p * y - f * d), _ = p * p + f * f, m = d * d + y * y, x = [(y * _ - f * m) / v + c, (p * m - d * _) / v + h]; ia(n.edge, l, g, x), u.edge = na(l, t, null, x), n.edge = na(t, g, null, x), fa(e), fa(n) } else u.edge = na(e.site, u.site) } } function Ea(t, e) { var n = t.site, r = n[0], i = n[1], o = i - e; if (!o) return r; var s = t.P; if (!s) return -1 / 0; var a = (n = s.site)[0], u = n[1], l = u - e; if (!l) return a; var c = a - r, h = 1 / o - 1 / l, p = c / l; return h ? (-p + Math.sqrt(p * p - 2 * h * (c * c / (-2 * l) - u + l / 2 + i - o / 2))) / h + r : (r + a) / 2 } function ba(t, e) { var n = t.N; if (n) return Ea(n, e); var r = t.site; return r[1] === e ? r[0] : 1 / 0 } var wa, Ia, Na, Sa, Ca = 1e-6, Pa = 1e-12; function La(t, e) { return e[1] - t[1] || e[0] - t[0] } function Ma(t, e) { var n, r, i, o = t.sort(La).pop(); for (Sa = [], Ia = new Array(t.length), wa = new Ks, Na = new Ks; ;)if (i = ca, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x)) o[0] === n && o[1] === r || (xa(o), n = o[0], r = o[1]), o = t.pop(); else { if (!i) break; ma(i.arc) } if (function () { for (var t, e, n, r, i = 0, o = Ia.length; i < o; ++i)if ((t = Ia[i]) && (r = (e = t.halfedges).length)) { var s = new Array(r), a = new Array(r); for (n = 0; n < r; ++n)s[n] = n, a[n] = aa(t, Sa[e[n]]); for (s.sort((function (t, e) { return a[e] - a[t] })), n = 0; n < r; ++n)a[n] = e[s[n]]; for (n = 0; n < r; ++n)e[n] = a[n] } }(), e) { var s = +e[0][0], a = +e[0][1], u = +e[1][0], l = +e[1][1]; !function (t, e, n, r) { for (var i, o = Sa.length; o--;)sa(i = Sa[o], t, e, n, r) && oa(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > Ca || Math.abs(i[0][1] - i[1][1]) > Ca) || delete Sa[o] }(s, a, u, l), function (t, e, n, r) { var i, o, s, a, u, l, c, h, p, f, g, d, y = Ia.length, v = !0; for (i = 0; i < y; ++i)if (o = Ia[i]) { for (s = o.site, a = (u = o.halfedges).length; a--;)Sa[u[a]] || u.splice(a, 1); for (a = 0, l = u.length; a < l;)g = (f = la(o, Sa[u[a]]))[0], d = f[1], h = (c = ua(o, Sa[u[++a % l]]))[0], p = c[1], (Math.abs(g - h) > Ca || Math.abs(d - p) > Ca) && (u.splice(a, 0, Sa.push(ra(s, f, Math.abs(g - t) < Ca && r - d > Ca ? [t, Math.abs(h - t) < Ca ? p : r] : Math.abs(d - r) < Ca && n - g > Ca ? [Math.abs(p - r) < Ca ? h : n, r] : Math.abs(g - n) < Ca && d - e > Ca ? [n, Math.abs(h - n) < Ca ? p : e] : Math.abs(d - e) < Ca && g - t > Ca ? [Math.abs(p - e) < Ca ? h : t, e] : null)) - 1), ++l); l && (v = !1) } if (v) { var _, m, x, E = 1 / 0; for (i = 0, v = null; i < y; ++i)(o = Ia[i]) && (x = (_ = (s = o.site)[0] - t) * _ + (m = s[1] - e) * m) < E && (E = x, v = o); if (v) { var b = [t, e], w = [t, r], I = [n, r], N = [n, e]; v.halfedges.push(Sa.push(ra(s = v.site, b, w)) - 1, Sa.push(ra(s, w, I)) - 1, Sa.push(ra(s, I, N)) - 1, Sa.push(ra(s, N, b)) - 1) } } for (i = 0; i < y; ++i)(o = Ia[i]) && (o.halfedges.length || delete Ia[i]) }(s, a, u, l) } this.edges = Sa, this.cells = Ia, wa = Na = Sa = Ia = null } function Oa(t) { return (t = t.slice()).push(t[0]), l([t]) } function Ra(t, e, n, r) { var i = (r = r || {}).steps || 64, o = r.units || "kilometers", s = r.angle || 0, a = r.pivot || t, u = r.properties || t.properties || {}; if (!t) throw new Error("center is required"); if (!e) throw new Error("xSemiAxis is required"); if (!n) throw new Error("ySemiAxis is required"); if (!P(r)) throw new Error("options must be an object"); if (!C(i)) throw new Error("steps must be a number"); if (!C(s)) throw new Error("angle must be a number"); var c = R(t); if ("degrees" === o) var h = I(s); else e = qi(t, e, 90, { units: o }), n = qi(t, n, 0, { units: o }), e = R(e)[0] - c[0], n = R(n)[1] - c[1]; for (var p = [], f = 0; f < i; f += 1) { var g = -360 * f / i, d = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(Ta(g), 2)), y = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(Ta(g), 2)); if (g < -90 && g >= -270 && (d = -d), g < -180 && g >= -360 && (y = -y), "degrees" === o) { var v = d * Math.cos(h) + y * Math.sin(h), _ = y * Math.cos(h) - d * Math.sin(h); d = v, y = _ } p.push([d + c[0], y + c[1]]) } return p.push(p[0]), "degrees" === o ? l([p], u) : Zo(l([p], u), s, { pivot: a }) } function Ta(t) { var e = t * Math.PI / 180; return Math.tan(e) } function Aa(t, e) { void 0 === e && (e = {}); var n = 0, r = 0, i = 0; return W(t, (function (t, o, s) { var a = s[e.weight]; if (!C(a = null == a ? 1 : a)) throw new Error("weight value must be a number for feature index " + o); (a = Number(a)) > 0 && z(t, (function (t) { n += t[0] * a, r += t[1] * a, i += a })) })), a([n / i, r / i], e.properties, e) } function Da(t, e, n, r) { var i = n.properties.tolerance || .001, o = 0, s = 0, u = 0, l = 0; if (X(n, (function (e) { var n = e.properties.weight, r = null == n ? 1 : n; if (!C(r = Number(r))) throw new Error("weight value must be a number"); if (r > 0) { l += 1; var i = r * me(e, t); 0 === i && (i = 1); var a = r / i; o += e.geometry.coordinates[0] * a, s += e.geometry.coordinates[1] * a, u += a } })), l < 1) throw new Error("no features to measure"); var c = o / u, h = s / u; return 1 === l || 0 === r || Math.abs(c - e[0]) < i && Math.abs(h - e[1]) < i ? a([c, h], { medianCandidates: n.properties.medianCandidates }) : (n.properties.medianCandidates.push([c, h]), Da([c, h], t, n, r - 1)) } function Fa(t, e) { return { x: t[0] - e[0], y: t[1] - e[1] } } function ka(t, e) { var n = 0, r = 0; z(t, (function (i, o, s, a, u) { u > n && (n = u, r = o, e.push([])); var l = o - r, c = t.coordinates[u][l + 1], h = i[0], p = i[1], f = c[0], g = c[1]; e[u].push([.75 * h + .25 * f, .75 * p + .25 * g]), e[u].push([.25 * h + .75 * f, .25 * p + .75 * g]) }), !0), e.forEach((function (t) { t.push(t[0]) })) } function Ga(t, e) { var n = 0, r = 0, i = 0; z(t, (function (o, s, a, u, l) { u > i && (i = u, r = s, e.push([[]])), l > n && (n = l, r = s, e[u].push([])); var c = s - r, h = t.coordinates[u][l][c + 1], p = o[0], f = o[1], g = h[0], d = h[1]; e[u][l].push([.75 * p + .25 * g, .75 * f + .25 * d]), e[u][l].push([.25 * p + .75 * g, .25 * f + .75 * d]) }), !0), e.forEach((function (t) { t.forEach((function (t) { t.push(t[0]) })) })) } function qa(t, e, n) { void 0 === n && (n = 2); var r = R(t), i = R(e), o = r[0] - i[0], s = r[1] - i[1]; return 1 === n ? Math.abs(o) + Math.abs(s) : Math.pow(Math.pow(o, n) + Math.pow(s, n), 1 / n) } function Ba(t, e) { var n = (e = e || {}).threshold || 1e4, r = e.p || 2, i = e.binary || !1, o = e.alpha || -1, s = e.standardization || !1, a = []; X(t, (function (t) { a.push(xn(t)) })); for (var u = [], l = 0; l < a.length; l++)u[l] = []; for (l = 0; l < a.length; l++)for (var c = l; c < a.length; c++) { l === c && (u[l][c] = 0); var h = qa(a[l], a[c], r); u[l][c] = h, u[c][l] = h } for (l = 0; l < a.length; l++)for (c = 0; c < a.length; c++) { 0 !== (h = u[l][c]) && (u[l][c] = i ? h <= n ? 1 : 0 : h <= n ? Math.pow(h, o) : 0) } if (s) for (l = 0; l < a.length; l++) { var p = u[l].reduce((function (t, e) { return t + e }), 0); for (c = 0; c < a.length; c++)u[l][c] = u[l][c] / p } return u } function za(t) { for (var e = 0, n = 0, r = t; n < r.length; n++) { e += r[n] } return e / t.length } function ja(t, e) { return void 0 === e && (e = {}), Va(t, "mercator", e) } function Ua(t, e) { return void 0 === e && (e = {}), Va(t, "wgs84", e) } function Va(t, e, n) { void 0 === n && (n = {}); var r = (n = n || {}).mutate; if (!t) throw new Error("geojson is required"); return Array.isArray(t) && C(t[0]) ? t = "mercator" === e ? Xa(t) : Ya(t) : (!0 !== r && (t = Ie(t)), z(t, (function (t) { var n = "mercator" === e ? Xa(t) : Ya(t); t[0] = n[0], t[1] = n[1] }))), t } function Xa(t) { var e = Math.PI / 180, n = 6378137, r = 20037508.342789244, i = [n * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * function (t) { return t < 0 ? -1 : t > 0 ? 1 : 0 }(t[0])) * e, n * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * e))]; return i[0] > r && (i[0] = r), i[0] < -r && (i[0] = -r), i[1] > r && (i[1] = r), i[1] < -r && (i[1] = -r), i } function Ya(t) { var e = 180 / Math.PI, n = 6378137; return [t[0] * e / n, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e] } Ma.prototype = { constructor: Ma, polygons: function () { var t = this.edges; return this.cells.map((function (e) { var n = e.halfedges.map((function (n) { return ua(e, t[n]) })); return n.data = e.site.data, n })) }, triangles: function () { var t = [], e = this.edges; return this.cells.forEach((function (n, r) { if (o = (i = n.halfedges).length) for (var i, o, s, a, u, l, c = n.site, h = -1, p = e[i[o - 1]], f = p.left === c ? p.right : p.left; ++h < o;)s = f, f = (p = e[i[h]]).left === c ? p.right : p.left, s && f && r < s.index && r < f.index && (u = s, l = f, ((a = c)[0] - l[0]) * (u[1] - a[1]) - (a[0] - u[0]) * (l[1] - a[1]) < 0) && t.push([c.data, s.data, f.data]) })), t }, links: function () { return this.edges.filter((function (t) { return t.right })).map((function (t) { return { source: t.left.data, target: t.right.data } })) }, find: function (t, e, n) { for (var r, i, o = this, s = o._found || 0, a = o.cells.length; !(i = o.cells[s]);)if (++s >= a) return null; var u = t - i.site[0], l = e - i.site[1], c = u * u + l * l; do { i = o.cells[r = s], s = null, i.halfedges.forEach((function (n) { var r = o.edges[n], a = r.left; if (a !== i.site && a || (a = r.right)) { var u = t - a[0], l = e - a[1], h = u * u + l * l; h < c && (c = h, s = a.index) } })) } while (null !== s); return o._found = r, null == n || c <= n * n ? i.site : null } }; var Ha = Object.freeze({ __proto__: null, toMercator: ja, toWgs84: Ua }); function Wa(t) { return Array.isArray(t) ? $a(t) : t && t.bbox ? $a(t.bbox) : [360 * Qa(), 180 * Qa()] } function Ja(t, e) { void 0 === e && (e = {}), null == t && (t = 1); for (var n = [], r = 0; r < t; r++)n.push(a(Wa(e.bbox))); return f(n) } function Za(t, e) { void 0 === e && (e = {}), null == t && (t = 1), C(e.num_vertices) && void 0 !== e.num_vertices || (e.num_vertices = 10), C(e.max_radial_length) && void 0 !== e.max_radial_length || (e.max_radial_length = 10); for (var n = [], r = function (t) { var r, i = [], o = Array.apply(null, new Array(e.num_vertices + 1)).map(Math.random); o.forEach((function (t, e, n) { n[e] = e > 0 ? t + n[e - 1] : t })), o.forEach((function (t) { t = 2 * t * Math.PI / o[o.length - 1]; var n = Math.random(); i.push([n * (e.max_radial_length || 10) * Math.sin(t), n * (e.max_radial_length || 10) * Math.cos(t)]) })), i[i.length - 1] = i[0], i = i.map((r = Wa(e.bbox), function (t) { return [t[0] + r[0], t[1] + r[1]] })), n.push(l([i])) }, i = 0; i < t; i++)r(); return f(n) } function Ka(t, e) { if (void 0 === e && (e = {}), !P(e = e || {})) throw new Error("options is invalid"); var n = e.bbox, r = e.num_vertices, i = e.max_length, o = e.max_rotation; null == t && (t = 1), (!C(r) || void 0 === r || r < 2) && (r = 10), C(i) && void 0 !== i || (i = 1e-4), C(o) && void 0 !== o || (o = Math.PI / 8); for (var s = [], a = 0; a < t; a++) { for (var u = [Wa(n)], l = 0; l < r - 1; l++) { var c = (0 === l ? 2 * Math.random() * Math.PI : Math.tan((u[l][1] - u[l - 1][1]) / (u[l][0] - u[l - 1][0]))) + (Math.random() - .5) * o * 2, p = Math.random() * i; u.push([u[l][0] + p * Math.cos(c), u[l][1] + p * Math.sin(c)]) } s.push(h(u)) } return f(s) } function Qa() { return Math.random() - .5 } function $a(t) { return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]] } var tu = Object.freeze({ __proto__: null, randomPosition: Wa, randomPoint: Ja, randomPolygon: Za, randomLineString: Ka }); function eu(t, e) { if (!t) throw new Error("geojson is required"); if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection"); if (null == e) throw new Error("filter is required"); var n = []; return X(t, (function (t) { ou(t.properties, e) && n.push(t) })), f(n) } function nu(t, e, n) { if (!t) throw new Error("geojson is required"); if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection"); if (null == e) throw new Error("property is required"); for (var r = iu(t, e), i = Object.keys(r), o = 0; o < i.length; o++) { for (var s = i[o], a = r[s], u = [], l = 0; l < a.length; l++)u.push(t.features[a[l]]); n(f(u), s, o) } } function ru(t, e, n, r) { var i = r; return nu(t, e, (function (t, e, o) { i = 0 === o && void 0 === r ? t : n(i, t, e, o) })), i } function iu(t, e) { var n = {}; return X(t, (function (t, r) { var i = t.properties || {}; if (i.hasOwnProperty(String(e))) { var o = i[e]; n.hasOwnProperty(o) ? n[o].push(r) : n[o] = [r] } })), n } function ou(t, e) { if (void 0 === t) return !1; var n = typeof e; if ("number" === n || "string" === n) return t.hasOwnProperty(e); if (Array.isArray(e)) { for (var r = 0; r < e.length; r++)if (!ou(t, e[r])) return !1; return !0 } return su(t, e) } function su(t, e) { for (var n = Object.keys(e), r = 0; r < n.length; r++) { var i = n[r]; if (t[i] !== e[i]) return !1 } return !0 } function au(t, e) { if (!e) return {}; if (!e.length) return {}; for (var n = {}, r = 0; r < e.length; r++) { var i = e[r]; t.hasOwnProperty(i) && (n[i] = t[i]) } return n } var uu = Object.freeze({ __proto__: null, getCluster: eu, clusterEach: nu, clusterReduce: ru, createBins: iu, applyFilter: ou, propertiesContainsFilter: su, filterProperties: au }), lu = function (t, e) { this.next = null, this.key = t, this.data = e, this.left = null, this.right = null };
/**
     * splaytree v3.1.0
     * Fast Splay tree for Node and browser
     *
     * @author Alexander Milevski <info@w8r.name>
     * @license MIT
     * @preserve
     */function cu(t, e) { return t > e ? 1 : t < e ? -1 : 0 } function hu(t, e, n) { for (var r = new lu(null, null), i = r, o = r; ;) { var s = n(t, e.key); if (s < 0) { if (null === e.left) break; if (n(t, e.left.key) < 0) { var a = e.left; if (e.left = a.right, a.right = e, null === (e = a).left) break } o.left = e, o = e, e = e.left } else { if (!(s > 0)) break; if (null === e.right) break; if (n(t, e.right.key) > 0) { a = e.right; if (e.right = a.left, a.left = e, null === (e = a).right) break } i.right = e, i = e, e = e.right } } return i.right = e.left, o.left = e.right, e.left = r.right, e.right = r.left, e } function pu(t, e, n, r) { var i = new lu(t, e); if (null === n) return i.left = i.right = null, i; var o = r(t, (n = hu(t, n, r)).key); return o < 0 ? (i.left = n.left, i.right = n, n.left = null) : o >= 0 && (i.right = n.right, i.left = n, n.right = null), i } function fu(t, e, n) { var r = null, i = null; if (e) { var o = n((e = hu(t, e, n)).key, t); 0 === o ? (r = e.left, i = e.right) : o < 0 ? (i = e.right, e.right = null, r = e) : (r = e.left, e.left = null, i = e) } return { left: r, right: i } } function gu(t, e, n, r, i) { if (t) { r(e + (n ? "└── " : "├── ") + i(t) + "\n"); var o = e + (n ? "    " : "│   "); t.left && gu(t.left, o, !1, r, i), t.right && gu(t.right, o, !0, r, i) } } var du = function () { function t(t) { void 0 === t && (t = cu), this._root = null, this._size = 0, this._comparator = t } return t.prototype.insert = function (t, e) { return this._size++, this._root = pu(t, e, this._root, this._comparator) }, t.prototype.add = function (t, e) { var n = new lu(t, e); null === this._root && (n.left = n.right = null, this._size++, this._root = n); var r = this._comparator, i = hu(t, this._root, r), o = r(t, i.key); return 0 === o ? this._root = i : (o < 0 ? (n.left = i.left, n.right = i, i.left = null) : o > 0 && (n.right = i.right, n.left = i, i.right = null), this._size++, this._root = n), this._root }, t.prototype.remove = function (t) { this._root = this._remove(t, this._root, this._comparator) }, t.prototype._remove = function (t, e, n) { var r; return null === e ? null : 0 === n(t, (e = hu(t, e, n)).key) ? (null === e.left ? r = e.right : (r = hu(t, e.left, n)).right = e.right, this._size--, r) : e }, t.prototype.pop = function () { var t = this._root; if (t) { for (; t.left;)t = t.left; return this._root = hu(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data } } return null }, t.prototype.findStatic = function (t) { for (var e = this._root, n = this._comparator; e;) { var r = n(t, e.key); if (0 === r) return e; e = r < 0 ? e.left : e.right } return null }, t.prototype.find = function (t) { return this._root && (this._root = hu(t, this._root, this._comparator), 0 !== this._comparator(t, this._root.key)) ? null : this._root }, t.prototype.contains = function (t) { for (var e = this._root, n = this._comparator; e;) { var r = n(t, e.key); if (0 === r) return !0; e = r < 0 ? e.left : e.right } return !1 }, t.prototype.forEach = function (t, e) { for (var n = this._root, r = [], i = !1; !i;)null !== n ? (r.push(n), n = n.left) : 0 !== r.length ? (n = r.pop(), t.call(e, n), n = n.right) : i = !0; return this }, t.prototype.range = function (t, e, n, r) { for (var i = [], o = this._comparator, s = this._root; 0 !== i.length || s;)if (s) i.push(s), s = s.left; else { if (o((s = i.pop()).key, e) > 0) break; if (o(s.key, t) >= 0 && n.call(r, s)) return this; s = s.right } return this }, t.prototype.keys = function () { var t = []; return this.forEach((function (e) { var n = e.key; return t.push(n) })), t }, t.prototype.values = function () { var t = []; return this.forEach((function (e) { var n = e.data; return t.push(n) })), t }, t.prototype.min = function () { return this._root ? this.minNode(this._root).key : null }, t.prototype.max = function () { return this._root ? this.maxNode(this._root).key : null }, t.prototype.minNode = function (t) { if (void 0 === t && (t = this._root), t) for (; t.left;)t = t.left; return t }, t.prototype.maxNode = function (t) { if (void 0 === t && (t = this._root), t) for (; t.right;)t = t.right; return t }, t.prototype.at = function (t) { for (var e = this._root, n = !1, r = 0, i = []; !n;)if (e) i.push(e), e = e.left; else if (i.length > 0) { if (e = i.pop(), r === t) return e; r++, e = e.right } else n = !0; return null }, t.prototype.next = function (t) { var e = this._root, n = null; if (t.right) { for (n = t.right; n.left;)n = n.left; return n } for (var r = this._comparator; e;) { var i = r(t.key, e.key); if (0 === i) break; i < 0 ? (n = e, e = e.left) : e = e.right } return n }, t.prototype.prev = function (t) { var e = this._root, n = null; if (null !== t.left) { for (n = t.left; n.right;)n = n.right; return n } for (var r = this._comparator; e;) { var i = r(t.key, e.key); if (0 === i) break; i < 0 ? e = e.left : (n = e, e = e.right) } return n }, t.prototype.clear = function () { return this._root = null, this._size = 0, this }, t.prototype.toList = function () { return function (t) { var e = t, n = [], r = !1, i = new lu(null, null), o = i; for (; !r;)e ? (n.push(e), e = e.left) : n.length > 0 ? e = (e = o = o.next = n.pop()).right : r = !0; return o.next = null, i.next }(this._root) }, t.prototype.load = function (t, e, n) { void 0 === e && (e = []), void 0 === n && (n = !1); var r = t.length, i = this._comparator; if (n && _u(t, e, 0, r - 1, i), null === this._root) this._root = yu(t, e, 0, r), this._size = r; else { var o = function (t, e, n) { var r = new lu(null, null), i = r, o = t, s = e; for (; null !== o && null !== s;)n(o.key, s.key) < 0 ? (i.next = o, o = o.next) : (i.next = s, s = s.next), i = i.next; null !== o ? i.next = o : null !== s && (i.next = s); return r.next }(this.toList(), function (t, e) { for (var n = new lu(null, null), r = n, i = 0; i < t.length; i++)r = r.next = new lu(t[i], e[i]); return r.next = null, n.next }(t, e), i); r = this._size + r, this._root = vu({ head: o }, 0, r) } return this }, t.prototype.isEmpty = function () { return null === this._root }, Object.defineProperty(t.prototype, "size", { get: function () { return this._size }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "root", { get: function () { return this._root }, enumerable: !0, configurable: !0 }), t.prototype.toString = function (t) { void 0 === t && (t = function (t) { return String(t.key) }); var e = []; return gu(this._root, "", !0, (function (t) { return e.push(t) }), t), e.join("") }, t.prototype.update = function (t, e, n) { var r = this._comparator, i = fu(t, this._root, r), o = i.left, s = i.right; r(t, e) < 0 ? s = pu(e, n, s, r) : o = pu(e, n, o, r), this._root = function (t, e, n) { return null === e ? t : (null === t || ((e = hu(t.key, e, n)).left = t), e) }(o, s, r) }, t.prototype.split = function (t) { return fu(t, this._root, this._comparator) }, t }(); function yu(t, e, n, r) { var i = r - n; if (i > 0) { var o = n + Math.floor(i / 2), s = t[o], a = e[o], u = new lu(s, a); return u.left = yu(t, e, n, o), u.right = yu(t, e, o + 1, r), u } return null } function vu(t, e, n) { var r = n - e; if (r > 0) { var i = e + Math.floor(r / 2), o = vu(t, e, i), s = t.head; return s.left = o, t.head = t.head.next, s.right = vu(t, i + 1, n), s } return null } function _u(t, e, n, r, i) { if (!(n >= r)) { for (var o = t[n + r >> 1], s = n - 1, a = r + 1; ;) { do { s++ } while (i(t[s], o) < 0); do { a-- } while (i(t[a], o) > 0); if (s >= a) break; var u = t[s]; t[s] = t[a], t[a] = u, u = e[s], e[s] = e[a], e[a] = u } _u(t, e, n, a, i), _u(t, e, a + 1, r, i) } } function mu(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function xu(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function Eu(t, e, n) { return e && xu(t.prototype, e), n && xu(t, n), t } var bu = function (t, e) { return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y }, wu = function (t, e) { if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null; var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x, r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x; return { ll: { x: n, y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y }, ur: { x: r, y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y } } }, Iu = Number.EPSILON; void 0 === Iu && (Iu = Math.pow(2, -52)); var Nu = Iu * Iu, Su = function (t, e) { if (-Iu < t && t < Iu && -Iu < e && e < Iu) return 0; var n = t - e; return n * n < Nu * t * e ? 0 : t < e ? -1 : 1 }, Cu = function () { function t() { mu(this, t), this.reset() } return Eu(t, [{ key: "reset", value: function () { this.xRounder = new Pu, this.yRounder = new Pu } }, { key: "round", value: function (t, e) { return { x: this.xRounder.round(t), y: this.yRounder.round(e) } } }]), t }(), Pu = function () { function t() { mu(this, t), this.tree = new du, this.round(0) } return Eu(t, [{ key: "round", value: function (t) { var e = this.tree.add(t), n = this.tree.prev(e); if (null !== n && 0 === Su(e.key, n.key)) return this.tree.remove(t), n.key; var r = this.tree.next(e); return null !== r && 0 === Su(e.key, r.key) ? (this.tree.remove(t), r.key) : t } }]), t }(), Lu = new Cu, Mu = function (t, e) { return t.x * e.y - t.y * e.x }, Ou = function (t, e) { return t.x * e.x + t.y * e.y }, Ru = function (t, e, n) { var r = { x: e.x - t.x, y: e.y - t.y }, i = { x: n.x - t.x, y: n.y - t.y }, o = Mu(r, i); return Su(o, 0) }, Tu = function (t) { return Math.sqrt(Ou(t, t)) }, Au = function (t, e, n) { var r = { x: e.x - t.x, y: e.y - t.y }, i = { x: n.x - t.x, y: n.y - t.y }; return Ou(i, r) / Tu(i) / Tu(r) }, Du = function (t, e, n) { return 0 === e.y ? null : { x: t.x + e.x / e.y * (n - t.y), y: n } }, Fu = function (t, e, n) { return 0 === e.x ? null : { x: n, y: t.y + e.y / e.x * (n - t.x) } }, ku = function () { function t(e, n) { mu(this, t), void 0 === e.events ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = n } return Eu(t, null, [{ key: "compare", value: function (e, n) { var r = t.comparePoints(e.point, n.point); return 0 !== r ? r : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : qu.compare(e.segment, n.segment)) } }, { key: "comparePoints", value: function (t, e) { return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0 } }]), Eu(t, [{ key: "link", value: function (t) { if (t.point === this.point) throw new Error("Tried to link already linked events"); for (var e = t.point.events, n = 0, r = e.length; n < r; n++) { var i = e[n]; this.point.events.push(i), i.point = this.point } this.checkForConsuming() } }, { key: "checkForConsuming", value: function () { for (var t = this.point.events.length, e = 0; e < t; e++) { var n = this.point.events[e]; if (void 0 === n.segment.consumedBy) for (var r = e + 1; r < t; r++) { var i = this.point.events[r]; void 0 === i.consumedBy && (n.otherSE.point.events === i.otherSE.point.events && n.segment.consume(i.segment)) } } } }, { key: "getAvailableLinkedEvents", value: function () { for (var t = [], e = 0, n = this.point.events.length; e < n; e++) { var r = this.point.events[e]; r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r) } return t } }, { key: "getLeftmostComparator", value: function (t) { var e = this, n = new Map, r = function (r) { var i, o, s, a, u, l = r.otherSE; n.set(r, { sine: (i = e.point, o = t.point, s = l.point, a = { x: o.x - i.x, y: o.y - i.y }, u = { x: s.x - i.x, y: s.y - i.y }, Mu(u, a) / Tu(u) / Tu(a)), cosine: Au(e.point, t.point, l.point) }) }; return function (t, e) { n.has(t) || r(t), n.has(e) || r(e); var i = n.get(t), o = i.sine, s = i.cosine, a = n.get(e), u = a.sine, l = a.cosine; return o >= 0 && u >= 0 ? s < l ? 1 : s > l ? -1 : 0 : o < 0 && u < 0 ? s < l ? -1 : s > l ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0 } } }]), t }(), Gu = 0, qu = function () { function t(e, n, r, i) { mu(this, t), this.id = ++Gu, this.leftSE = e, e.segment = this, e.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = e, this.rings = r, this.windings = i } return Eu(t, null, [{ key: "compare", value: function (t, e) { var n = t.leftSE.point.x, r = e.leftSE.point.x, i = t.rightSE.point.x, o = e.rightSE.point.x; if (o < n) return 1; if (i < r) return -1; var s = t.leftSE.point.y, a = e.leftSE.point.y, u = t.rightSE.point.y, l = e.rightSE.point.y; if (n < r) { if (a < s && a < u) return 1; if (a > s && a > u) return -1; var c = t.comparePoint(e.leftSE.point); if (c < 0) return 1; if (c > 0) return -1; var h = e.comparePoint(t.rightSE.point); return 0 !== h ? h : -1 } if (n > r) { if (s < a && s < l) return -1; if (s > a && s > l) return 1; var p = e.comparePoint(t.leftSE.point); if (0 !== p) return p; var f = t.comparePoint(e.rightSE.point); return f < 0 ? 1 : f > 0 ? -1 : 1 } if (s < a) return -1; if (s > a) return 1; if (i < o) { var g = e.comparePoint(t.rightSE.point); if (0 !== g) return g } if (i > o) { var d = t.comparePoint(e.rightSE.point); if (d < 0) return 1; if (d > 0) return -1 } if (i !== o) { var y = u - s, v = i - n, _ = l - a, m = o - r; if (y > v && _ < m) return 1; if (y < v && _ > m) return -1 } return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0 } }]), Eu(t, [{ key: "replaceRightSE", value: function (t) { this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE } }, { key: "bbox", value: function () { var t = this.leftSE.point.y, e = this.rightSE.point.y; return { ll: { x: this.leftSE.point.x, y: t < e ? t : e }, ur: { x: this.rightSE.point.x, y: t > e ? t : e } } } }, { key: "vector", value: function () { return { x: this.rightSE.point.x - this.leftSE.point.x, y: this.rightSE.point.y - this.leftSE.point.y } } }, { key: "isAnEndpoint", value: function (t) { return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y } }, { key: "comparePoint", value: function (t) { if (this.isAnEndpoint(t)) return 0; var e = this.leftSE.point, n = this.rightSE.point, r = this.vector(); if (e.x === n.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1; var i = (t.y - e.y) / r.y, o = e.x + i * r.x; if (t.x === o) return 0; var s = (t.x - e.x) / r.x, a = e.y + s * r.y; return t.y === a ? 0 : t.y < a ? -1 : 1 } }, { key: "getIntersection", value: function (t) { var e = this.bbox(), n = t.bbox(), r = wu(e, n); if (null === r) return null; var i = this.leftSE.point, o = this.rightSE.point, s = t.leftSE.point, a = t.rightSE.point, u = bu(e, s) && 0 === this.comparePoint(s), l = bu(n, i) && 0 === t.comparePoint(i), c = bu(e, a) && 0 === this.comparePoint(a), h = bu(n, o) && 0 === t.comparePoint(o); if (l && u) return h && !c ? o : !h && c ? a : null; if (l) return c && i.x === a.x && i.y === a.y ? null : i; if (u) return h && o.x === s.x && o.y === s.y ? null : s; if (h && c) return null; if (h) return o; if (c) return a; var p = function (t, e, n, r) { if (0 === e.x) return Fu(n, r, t.x); if (0 === r.x) return Fu(t, e, n.x); if (0 === e.y) return Du(n, r, t.y); if (0 === r.y) return Du(t, e, n.y); var i = Mu(e, r); if (0 == i) return null; var o = { x: n.x - t.x, y: n.y - t.y }, s = Mu(o, e) / i, a = Mu(o, r) / i; return { x: (t.x + a * e.x + (n.x + s * r.x)) / 2, y: (t.y + a * e.y + (n.y + s * r.y)) / 2 } }(i, this.vector(), s, t.vector()); return null === p ? null : bu(r, p) ? Lu.round(p.x, p.y) : null } }, { key: "split", value: function (e) { var n = [], r = void 0 !== e.events, i = new ku(e, !0), o = new ku(e, !1), s = this.rightSE; this.replaceRightSE(o), n.push(o), n.push(i); var a = new t(i, s, this.rings.slice(), this.windings.slice()); return ku.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), ku.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (i.checkForConsuming(), o.checkForConsuming()), n } }, { key: "swapEvents", value: function () { var t = this.rightSE; this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1; for (var e = 0, n = this.windings.length; e < n; e++)this.windings[e] *= -1 } }, { key: "consume", value: function (e) { for (var n = this, r = e; n.consumedBy;)n = n.consumedBy; for (; r.consumedBy;)r = r.consumedBy; var i = t.compare(n, r); if (0 !== i) { if (i > 0) { var o = n; n = r, r = o } if (n.prev === r) { var s = n; n = r, r = s } for (var a = 0, u = r.rings.length; a < u; a++) { var l = r.rings[a], c = r.windings[a], h = n.rings.indexOf(l); -1 === h ? (n.rings.push(l), n.windings.push(c)) : n.windings[h] += c } r.rings = null, r.windings = null, r.consumedBy = n, r.leftSE.consumedBy = n.leftSE, r.rightSE.consumedBy = n.rightSE } } }, { key: "prevInResult", value: function () { return void 0 !== this._prevInResult || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult } }, { key: "beforeState", value: function () { if (void 0 !== this._beforeState) return this._beforeState; if (this.prev) { var t = this.prev.consumedBy || this.prev; this._beforeState = t.afterState() } else this._beforeState = { rings: [], windings: [], multiPolys: [] }; return this._beforeState } }, { key: "afterState", value: function () { if (void 0 !== this._afterState) return this._afterState; var t = this.beforeState(); this._afterState = { rings: t.rings.slice(0), windings: t.windings.slice(0), multiPolys: [] }; for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, i = 0, o = this.rings.length; i < o; i++) { var s = this.rings[i], a = this.windings[i], u = e.indexOf(s); -1 === u ? (e.push(s), n.push(a)) : n[u] += a } for (var l = [], c = [], h = 0, p = e.length; h < p; h++)if (0 !== n[h]) { var f = e[h], g = f.poly; if (-1 === c.indexOf(g)) if (f.isExterior) l.push(g); else { -1 === c.indexOf(g) && c.push(g); var d = l.indexOf(f.poly); -1 !== d && l.splice(d, 1) } } for (var y = 0, v = l.length; y < v; y++) { var _ = l[y].multiPoly; -1 === r.indexOf(_) && r.push(_) } return this._afterState } }, { key: "isInResult", value: function () { if (this.consumedBy) return !1; if (void 0 !== this._isInResult) return this._isInResult; var t = this.beforeState().multiPolys, e = this.afterState().multiPolys; switch (Ju.type) { case "union": var n = 0 === t.length, r = 0 === e.length; this._isInResult = n !== r; break; case "intersection": var i, o; t.length < e.length ? (i = t.length, o = e.length) : (i = e.length, o = t.length), this._isInResult = o === Ju.numMultiPolys && i < o; break; case "xor": var s = Math.abs(t.length - e.length); this._isInResult = s % 2 == 1; break; case "difference": var a = function (t) { return 1 === t.length && t[0].isSubject }; this._isInResult = a(t) !== a(e); break; default: throw new Error("Unrecognized operation type found ".concat(Ju.type)) }return this._isInResult } }], [{ key: "fromRing", value: function (e, n, r) { var i, o, s, a = ku.comparePoints(e, n); if (a < 0) i = e, o = n, s = 1; else { if (!(a > 0)) throw new Error("Tried to create degenerate segment at [".concat(e.x, ", ").concat(e.y, "]")); i = n, o = e, s = -1 } return new t(new ku(i, !0), new ku(o, !1), [r], [s]) } }]), t }(), Bu = function () { function t(e, n, r) { if (mu(this, t), !Array.isArray(e) || 0 === e.length) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); if (this.poly = n, this.isExterior = r, this.segments = [], "number" != typeof e[0][0] || "number" != typeof e[0][1]) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); var i = Lu.round(e[0][0], e[0][1]); this.bbox = { ll: { x: i.x, y: i.y }, ur: { x: i.x, y: i.y } }; for (var o = i, s = 1, a = e.length; s < a; s++) { if ("number" != typeof e[s][0] || "number" != typeof e[s][1]) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); var u = Lu.round(e[s][0], e[s][1]); u.x === o.x && u.y === o.y || (this.segments.push(qu.fromRing(o, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), o = u) } i.x === o.x && i.y === o.y || this.segments.push(qu.fromRing(o, i, this)) } return Eu(t, [{ key: "getSweepEvents", value: function () { for (var t = [], e = 0, n = this.segments.length; e < n; e++) { var r = this.segments[e]; t.push(r.leftSE), t.push(r.rightSE) } return t } }]), t }(), zu = function () { function t(e, n) { if (mu(this, t), !Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); this.exteriorRing = new Bu(e[0], this, !0), this.bbox = { ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y }, ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y } }, this.interiorRings = []; for (var r = 1, i = e.length; r < i; r++) { var o = new Bu(e[r], this, !1); o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.interiorRings.push(o) } this.multiPoly = n } return Eu(t, [{ key: "getSweepEvents", value: function () { for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++)for (var r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)t.push(r[i]); return t } }]), t }(), ju = function () { function t(e, n) { if (mu(this, t), !Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); try { "number" == typeof e[0][0][0] && (e = [e]) } catch (t) { } this.polys = [], this.bbox = { ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY }, ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY } }; for (var r = 0, i = e.length; r < i; r++) { var o = new zu(e[r], this); o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.polys.push(o) } this.isSubject = n } return Eu(t, [{ key: "getSweepEvents", value: function () { for (var t = [], e = 0, n = this.polys.length; e < n; e++)for (var r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)t.push(r[i]); return t } }]), t }(), Uu = function () { function t(e) { mu(this, t), this.events = e; for (var n = 0, r = e.length; n < r; n++)e[n].segment.ringOut = this; this.poly = null } return Eu(t, null, [{ key: "factory", value: function (e) { for (var n = [], r = 0, i = e.length; r < i; r++) { var o = e[r]; if (o.isInResult() && !o.ringOut) { for (var s = null, a = o.leftSE, u = o.rightSE, l = [a], c = a.point, h = []; s = a, a = u, l.push(a), a.point !== c;)for (; ;) { var p = a.getAvailableLinkedEvents(); if (0 === p.length) { var f = l[0].point, g = l[l.length - 1].point; throw new Error("Unable to complete output ring starting at [".concat(f.x, ",") + " ".concat(f.y, "]. Last matching segment found ends at") + " [".concat(g.x, ", ").concat(g.y, "].")) } if (1 === p.length) { u = p[0].otherSE; break } for (var d = null, y = 0, v = h.length; y < v; y++)if (h[y].point === a.point) { d = y; break } if (null === d) { h.push({ index: l.length, point: a.point }); var _ = a.getLeftmostComparator(s); u = p.sort(_)[0].otherSE; break } var m = h.splice(d)[0], x = l.splice(m.index); x.unshift(x[0].otherSE), n.push(new t(x.reverse())) } n.push(new t(l)) } } return n } }]), Eu(t, [{ key: "getGeom", value: function () { for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) { var i = this.events[n].point, o = this.events[n + 1].point; 0 !== Ru(i, t, o) && (e.push(i), t = i) } if (1 === e.length) return null; var s = e[0], a = e[1]; 0 === Ru(s, t, a) && e.shift(), e.push(e[0]); for (var u = this.isExteriorRing() ? 1 : -1, l = this.isExteriorRing() ? 0 : e.length - 1, c = this.isExteriorRing() ? e.length : -1, h = [], p = l; p != c; p += u)h.push([e[p].x, e[p].y]); return h } }, { key: "isExteriorRing", value: function () { if (void 0 === this._isExteriorRing) { var t = this.enclosingRing(); this._isExteriorRing = !t || !t.isExteriorRing() } return this._isExteriorRing } }, { key: "enclosingRing", value: function () { return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing } }, { key: "_calcEnclosingRing", value: function () { for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) { var r = this.events[e]; ku.compare(t, r) > 0 && (t = r) } for (var i = t.segment.prevInResult(), o = i ? i.prevInResult() : null; ;) { if (!i) return null; if (!o) return i.ringOut; if (o.ringOut !== i.ringOut) return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing(); i = o.prevInResult(), o = i ? i.prevInResult() : null } } }]), t }(), Vu = function () { function t(e) { mu(this, t), this.exteriorRing = e, e.poly = this, this.interiorRings = [] } return Eu(t, [{ key: "addInterior", value: function (t) { this.interiorRings.push(t), t.poly = this } }, { key: "getGeom", value: function () { var t = [this.exteriorRing.getGeom()]; if (null === t[0]) return null; for (var e = 0, n = this.interiorRings.length; e < n; e++) { var r = this.interiorRings[e].getGeom(); null !== r && t.push(r) } return t } }]), t }(), Xu = function () { function t(e) { mu(this, t), this.rings = e, this.polys = this._composePolys(e) } return Eu(t, [{ key: "getGeom", value: function () { for (var t = [], e = 0, n = this.polys.length; e < n; e++) { var r = this.polys[e].getGeom(); null !== r && t.push(r) } return t } }, { key: "_composePolys", value: function (t) { for (var e = [], n = 0, r = t.length; n < r; n++) { var i = t[n]; if (!i.poly) if (i.isExteriorRing()) e.push(new Vu(i)); else { var o = i.enclosingRing(); o.poly || e.push(new Vu(o)), o.poly.addInterior(i) } } return e } }]), t }(), Yu = function () { function t(e) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : qu.compare; mu(this, t), this.queue = e, this.tree = new du(n), this.segments = [] } return Eu(t, [{ key: "process", value: function (t) { var e = t.segment, n = []; if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n; var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e); if (!r) throw new Error("Unable to find segment #".concat(e.id, " ") + "[".concat(e.leftSE.point.x, ", ").concat(e.leftSE.point.y, "] -> ") + "[".concat(e.rightSE.point.x, ", ").concat(e.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report."); for (var i = r, o = r, s = void 0, a = void 0; void 0 === s;)null === (i = this.tree.prev(i)) ? s = null : void 0 === i.key.consumedBy && (s = i.key); for (; void 0 === a;)null === (o = this.tree.next(o)) ? a = null : void 0 === o.key.consumedBy && (a = o.key); if (t.isLeft) { var u = null; if (s) { var l = s.getIntersection(e); if (null !== l && (e.isAnEndpoint(l) || (u = l), !s.isAnEndpoint(l))) for (var c = this._splitSafely(s, l), h = 0, p = c.length; h < p; h++)n.push(c[h]) } var f = null; if (a) { var g = a.getIntersection(e); if (null !== g && (e.isAnEndpoint(g) || (f = g), !a.isAnEndpoint(g))) for (var d = this._splitSafely(a, g), y = 0, v = d.length; y < v; y++)n.push(d[y]) } if (null !== u || null !== f) { var _ = null; if (null === u) _ = f; else if (null === f) _ = u; else { _ = ku.comparePoints(u, f) <= 0 ? u : f } this.queue.remove(e.rightSE), n.push(e.rightSE); for (var m = e.split(_), x = 0, E = m.length; x < E; x++)n.push(m[x]) } n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = s) } else { if (s && a) { var b = s.getIntersection(a); if (null !== b) { if (!s.isAnEndpoint(b)) for (var w = this._splitSafely(s, b), I = 0, N = w.length; I < N; I++)n.push(w[I]); if (!a.isAnEndpoint(b)) for (var S = this._splitSafely(a, b), C = 0, P = S.length; C < P; C++)n.push(S[C]) } } this.tree.remove(e) } return n } }, { key: "_splitSafely", value: function (t, e) { this.tree.remove(t); var n = t.rightSE; this.queue.remove(n); var r = t.split(e); return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r } }]), t }(), Hu = "undefined" != typeof process && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, Wu = "undefined" != typeof process && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6, Ju = new (function () { function t() { mu(this, t) } return Eu(t, [{ key: "run", value: function (t, e, n) { Ju.type = t, Lu.reset(); for (var r = [new ju(e, !0)], i = 0, o = n.length; i < o; i++)r.push(new ju(n[i], !1)); if (Ju.numMultiPolys = r.length, "difference" === Ju.type) for (var s = r[0], a = 1; a < r.length;)null !== wu(r[a].bbox, s.bbox) ? a++ : r.splice(a, 1); if ("intersection" === Ju.type) for (var u = 0, l = r.length; u < l; u++)for (var c = r[u], h = u + 1, p = r.length; h < p; h++)if (null === wu(c.bbox, r[h].bbox)) return []; for (var f = new du(ku.compare), g = 0, d = r.length; g < d; g++)for (var y = r[g].getSweepEvents(), v = 0, _ = y.length; v < _; v++)if (f.insert(y[v]), f.size > Hu) throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report."); for (var m = new Yu(f), x = f.size, E = f.pop(); E;) { var b = E.key; if (f.size === x) { var w = b.segment; throw new Error("Unable to pop() ".concat(b.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(b.point.x, ", ").concat(b.point.y, "] from segment #").concat(w.id, " ") + "[".concat(w.leftSE.point.x, ", ").concat(w.leftSE.point.y, "] -> ") + "[".concat(w.rightSE.point.x, ", ").concat(w.rightSE.point.y, "] from queue. ") + "Please file a bug report.") } if (f.size > Hu) throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report."); if (m.segments.length > Wu) throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report."); for (var I = m.process(b), N = 0, S = I.length; N < S; N++) { var C = I[N]; void 0 === C.consumedBy && f.insert(C) } x = f.size, E = f.pop() } Lu.reset(); var P = Uu.factory(m.segments); return new Xu(P).getGeom() } }]), t }()), Zu = function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return Ju.run("union", t, n) }, Ku = function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return Ju.run("intersection", t, n) }, Qu = function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return Ju.run("difference", t, n) }; "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: !0, value: function (t) { if (null == this) throw new TypeError(this + " is not an object"); var e = Object(this), n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0, r = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0; r = r < 0 ? Math.max(n + r, 0) : Math.min(r, n); var i = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n; for (i = i < 0 ? Math.max(n + arguments[2], 0) : Math.min(i, n); r < i;)e[r] = t, ++r; return e }, writable: !0 }), Number.isFinite = Number.isFinite || function (t) { return "number" == typeof t && isFinite(t) }, Number.isInteger = Number.isInteger || function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) { return t != t }, Math.trunc = Math.trunc || function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t) }; var $u = function () { }; $u.prototype.interfaces_ = function () { return [] }, $u.prototype.getClass = function () { return $u }, $u.prototype.equalsWithTolerance = function (t, e, n) { return Math.abs(t - e) <= n }; var tl = function (t) { function e(e) { t.call(this, e), this.name = "IllegalArgumentException", this.message = e, this.stack = (new t).stack } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e }(Error), el = function () { }, nl = { MAX_VALUE: { configurable: !0 } }; el.isNaN = function (t) { return Number.isNaN(t) }, el.doubleToLongBits = function (t) { return t }, el.longBitsToDouble = function (t) { return t }, el.isInfinite = function (t) { return !Number.isFinite(t) }, nl.MAX_VALUE.get = function () { return Number.MAX_VALUE }, Object.defineProperties(el, nl); var rl = function () { }, il = function () { }, ol = function () { }; function sl() { } var al = function t() { if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE; else if (1 === arguments.length) { var e = arguments[0]; this.x = e.x, this.y = e.y, this.z = e.z } else 2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]) }, ul = { DimensionalComparator: { configurable: !0 }, serialVersionUID: { configurable: !0 }, NULL_ORDINATE: { configurable: !0 }, X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 } }; al.prototype.setOrdinate = function (t, e) { switch (t) { case al.X: this.x = e; break; case al.Y: this.y = e; break; case al.Z: this.z = e; break; default: throw new tl("Invalid ordinate index: " + t) } }, al.prototype.equals2D = function () { if (1 === arguments.length) { var t = arguments[0]; return this.x === t.x && this.y === t.y } if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; return !!$u.equalsWithTolerance(this.x, e.x, n) && !!$u.equalsWithTolerance(this.y, e.y, n) } }, al.prototype.getOrdinate = function (t) { switch (t) { case al.X: return this.x; case al.Y: return this.y; case al.Z: return this.z }throw new tl("Invalid ordinate index: " + t) }, al.prototype.equals3D = function (t) { return this.x === t.x && this.y === t.y && (this.z === t.z || el.isNaN(this.z)) && el.isNaN(t.z) }, al.prototype.equals = function (t) { return t instanceof al && this.equals2D(t) }, al.prototype.equalInZ = function (t, e) { return $u.equalsWithTolerance(this.z, t.z, e) }, al.prototype.compareTo = function (t) { var e = t; return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0 }, al.prototype.clone = function () { }, al.prototype.copy = function () { return new al(this) }, al.prototype.toString = function () { return "(" + this.x + ", " + this.y + ", " + this.z + ")" }, al.prototype.distance3D = function (t) { var e = this.x - t.x, n = this.y - t.y, r = this.z - t.z; return Math.sqrt(e * e + n * n + r * r) }, al.prototype.distance = function (t) { var e = this.x - t.x, n = this.y - t.y; return Math.sqrt(e * e + n * n) }, al.prototype.hashCode = function () { var t = 17; return t = 37 * (t = 37 * t + al.hashCode(this.x)) + al.hashCode(this.y) }, al.prototype.setCoordinate = function (t) { this.x = t.x, this.y = t.y, this.z = t.z }, al.prototype.interfaces_ = function () { return [rl, il, sl] }, al.prototype.getClass = function () { return al }, al.hashCode = function () { if (1 === arguments.length) { var t = arguments[0], e = el.doubleToLongBits(t); return Math.trunc((e ^ e) >>> 32) } }, ul.DimensionalComparator.get = function () { return ll }, ul.serialVersionUID.get = function () { return 0x5cbf2c235c7e5800 }, ul.NULL_ORDINATE.get = function () { return el.NaN }, ul.X.get = function () { return 0 }, ul.Y.get = function () { return 1 }, ul.Z.get = function () { return 2 }, Object.defineProperties(al, ul); var ll = function (t) { if (this._dimensionsToTest = 2, 0 === arguments.length); else if (1 === arguments.length) { var e = arguments[0]; if (2 !== e && 3 !== e) throw new tl("only 2 or 3 dimensions may be specified"); this._dimensionsToTest = e } }; ll.prototype.compare = function (t, e) { var n = t, r = e, i = ll.compare(n.x, r.x); if (0 !== i) return i; var o = ll.compare(n.y, r.y); return 0 !== o ? o : this._dimensionsToTest <= 2 ? 0 : ll.compare(n.z, r.z) }, ll.prototype.interfaces_ = function () { return [ol] }, ll.prototype.getClass = function () { return ll }, ll.compare = function (t, e) { return t < e ? -1 : t > e ? 1 : el.isNaN(t) ? el.isNaN(e) ? 0 : -1 : el.isNaN(e) ? 1 : 0 }; var cl = function () { }; cl.prototype.create = function () { }, cl.prototype.interfaces_ = function () { return [] }, cl.prototype.getClass = function () { return cl }; var hl = function () { }, pl = { INTERIOR: { configurable: !0 }, BOUNDARY: { configurable: !0 }, EXTERIOR: { configurable: !0 }, NONE: { configurable: !0 } }; hl.prototype.interfaces_ = function () { return [] }, hl.prototype.getClass = function () { return hl }, hl.toLocationSymbol = function (t) { switch (t) { case hl.EXTERIOR: return "e"; case hl.BOUNDARY: return "b"; case hl.INTERIOR: return "i"; case hl.NONE: return "-" }throw new tl("Unknown location value: " + t) }, pl.INTERIOR.get = function () { return 0 }, pl.BOUNDARY.get = function () { return 1 }, pl.EXTERIOR.get = function () { return 2 }, pl.NONE.get = function () { return -1 }, Object.defineProperties(hl, pl); var fl = function (t, e) { return t.interfaces_ && t.interfaces_().indexOf(e) > -1 }, gl = function () { }, dl = { LOG_10: { configurable: !0 } }; gl.prototype.interfaces_ = function () { return [] }, gl.prototype.getClass = function () { return gl }, gl.log10 = function (t) { var e = Math.log(t); return el.isInfinite(e) || el.isNaN(e) ? e : e / gl.LOG_10 }, gl.min = function (t, e, n, r) { var i = t; return e < i && (i = e), n < i && (i = n), r < i && (i = r), i }, gl.clamp = function () { if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { var t = arguments[0], e = arguments[1], n = arguments[2]; return t < e ? e : t > n ? n : t } if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { var r = arguments[0], i = arguments[1], o = arguments[2]; return r < i ? i : r > o ? o : r } }, gl.wrap = function (t, e) { return t < 0 ? e - -t % e : t % e }, gl.max = function () { if (3 === arguments.length) { var t = arguments[0], e = arguments[1], n = arguments[2], r = t; return e > r && (r = e), n > r && (r = n), r } if (4 === arguments.length) { var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3], u = i; return o > u && (u = o), s > u && (u = s), a > u && (u = a), u } }, gl.average = function (t, e) { return (t + e) / 2 }, dl.LOG_10.get = function () { return Math.log(10) }, Object.defineProperties(gl, dl); var yl = function (t) { this.str = t }; yl.prototype.append = function (t) { this.str += t }, yl.prototype.setCharAt = function (t, e) { this.str = this.str.substr(0, t) + e + this.str.substr(t + 1) }, yl.prototype.toString = function (t) { return this.str }; var vl = function (t) { this.value = t }; vl.prototype.intValue = function () { return this.value }, vl.prototype.compareTo = function (t) { return this.value < t ? -1 : this.value > t ? 1 : 0 }, vl.isNaN = function (t) { return Number.isNaN(t) }; var _l = function () { }; _l.isWhitespace = function (t) { return t <= 32 && t >= 0 || 127 === t }, _l.toUpperCase = function (t) { return t.toUpperCase() }; var ml = function t() { if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0); else if (1 === arguments.length) { if ("number" == typeof arguments[0]) { var e = arguments[0]; this.init(e) } else if (arguments[0] instanceof t) { var n = arguments[0]; this.init(n) } else if ("string" == typeof arguments[0]) { var r = arguments[0]; t.call(this, t.parse(r)) } } else if (2 === arguments.length) { var i = arguments[0], o = arguments[1]; this.init(i, o) } }, xl = { PI: { configurable: !0 }, TWO_PI: { configurable: !0 }, PI_2: { configurable: !0 }, E: { configurable: !0 }, NaN: { configurable: !0 }, EPS: { configurable: !0 }, SPLIT: { configurable: !0 }, MAX_PRINT_DIGITS: { configurable: !0 }, TEN: { configurable: !0 }, ONE: { configurable: !0 }, SCI_NOT_EXPONENT_CHAR: { configurable: !0 }, SCI_NOT_ZERO: { configurable: !0 } }; ml.prototype.le = function (t) { return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo }, ml.prototype.extractSignificantDigits = function (t, e) { var n = this.abs(), r = ml.magnitude(n._hi), i = ml.TEN.pow(r); (n = n.divide(i)).gt(ml.TEN) ? (n = n.divide(ml.TEN), r += 1) : n.lt(ml.ONE) && (n = n.multiply(ml.TEN), r -= 1); for (var o = r + 1, s = new yl, a = ml.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) { t && u === o && s.append("."); var l = Math.trunc(n._hi); if (l < 0) break; var c = !1, h = 0; l > 9 ? (c = !0, h = "9") : h = "0" + l, s.append(h), n = n.subtract(ml.valueOf(l)).multiply(ml.TEN), c && n.selfAdd(ml.TEN); var p = !0, f = ml.magnitude(n._hi); if (f < 0 && Math.abs(f) >= a - u && (p = !1), !p) break } return